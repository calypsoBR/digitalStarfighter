<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>O Último Guerreiro Digital das Estrelas</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }        
    </style>
</head>
<body>

   <button id="unmute" style="position:fixed; top:10px; left:10px; z-index:10000; padding:8px 15px; background:#0077ff; color:white; border:none; border-radius:5px; cursor:pointer;">
        CLIQUE AQUI PARA ATIVAR SOM
    </button>

    
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script>    

         // ===== [SISTEMA DE SONS SIMPLIFICADO] ===== //
            let audioEnabled = false;
            const sounds = {
                shoot: new Audio('./sounds/shoot.mp3'),
                explosion: new Audio('./sounds/explosion.mp3'),
                powerup: new Audio('./sounds/powerup.mp3'),
                gameOver: new Audio('./sounds/game_over.mp3'),
                victory: new Audio('./sounds/victory.mp3'),
                powerupCollect: new Audio('./sounds/powerup_collect.mp3')
            };
            
            Object.values(sounds).forEach(audio => {
                audio.volume = 0.3;
            });
            
            function enableAudio() {
                audioEnabled = true;
                Object.values(sounds).forEach(audio => {
                    audio.play().then(() => {
                        audio.pause();
                        audio.currentTime = 0;
                    }).catch(e => console.log("Pré-carregamento falhou:", e));
                });
            }
            
            function playSound(name) {
                if (!audioEnabled) return;
                try {
                    sounds[name].currentTime = 0;
                    sounds[name].play().catch(e => console.log(`Erro ao tocar ${name}:`, e));
                } catch (e) {
                    console.error("Erro fatal no sistema de áudio:", e);
                }
            }
            
            document.getElementById('unmute').addEventListener('click', () => {
                enableAudio();
                document.getElementById('unmute').style.display = 'none';
            });
      // ===== [FIM DA SEÇÃO DE SONS] ===== //
             
        
        // ===== [DEFINIÇÃO DOS ESTADOS DO JOGO] ===== //
        const GAME_STATE = {
            START: 0,      // Estado inicial (tela de título)
            PLAYING: 1,    // Jogo em andamento
            PAUSED: 2,     // Jogo pausado
            GAME_OVER: 3,  // Derrota (exibindo tela de game over)
            WIN: 4         // Vitória (inimigos derrotados)
        };

        // ===== [CONTROLE DE WAVES/FASES] ===== //
        let wave = 1,       // Fase atual (começa na wave 1)
            maxWaves = 10,  // Número total de waves (última é a nave-mãe com escolta)
            waveEnemies = 0; // Contador de inimigos restantes na wave atual

        // ===== [ TIPOS DE "BOMBAS" (OPERADORES LÓGICOS)  ] ===== //         
        const OPERATORS = [
            { key: 'AND', fn: (a, b) => a & b },
            { key: 'OR', fn: (a, b) => a | b },
            { key: 'XOR', fn: (a, b) => a ^ b },           
            { key: 'NAND', fn: (a, b) => 1 - (a & b) },
            { key: 'NOR', fn: (a, b) => 1 - (a | b) },
            { key: 'XNOR', fn: (a, b) => 1 - (a ^ b) }
        ];

        // ===== [ TIPOS DE INIMIGOS (NAVES E SUAS CARACTERÍSTICAS) ] ===== //
        const ENEMY_TYPES = [
            
        // --- NÍVEL 1 (caças, com valor lógico constante, gearado aleatoriamente)
            
            {   shape: 'cube', ev: () => Math.round(Math.random()),   // define nave, gera valor lógico de forma aleatória
                isDynamic: false  // valor não muda após ser gerado
            },

            
        // --- NÍVEL 2 (caças, com valor mudando a cada "changeInterval" segundos, gearado aleatoriamente)
            
            {   shape: 'cube', ev: () => Math.round(Math.random()),  // define nave, gera valor lógico de forma aleatória
                isDynamic: true, changeInterval: 3  // muda o valor a cada 3 segundos
            },

            
         // --- NÍVEL 3 (caças, com valor mudando a cada "changeInterval" segundos, condicionado ao PSB ou seu contraditório)
            
            {   shape: 'cube', ev: (psb) => Math.random() > 0.5 ? psb : 1 - psb, // define nave, gera valor com 50% de chance de ser psb ou !psb
                isDynamic: true, changeInterval: 4   // muda o valor a cada 4 segundos
            },

            
        // --- NÍVEL 4 (cruzadores, com expressão básicas, com valor de A e B constante, gerados aleatoriamente)

            // 1) Operação AND
            {     shape: 'tetra', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),
                  ev: function() { return this.A() & this.B(); },  // Cálculo real: A AND B
                  ab: true, expr: 'A.B', // Exibição visual
                  isDynamic: false  // não muda os valores de A e B
            },

            // 2) Operação OR
            {   shape: 'tetra', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),
                ev: function() { return this.A() | this.B(); }, // Cálculo real: A OR B
                ab: true, expr: 'A+B', // Exibição visual
                isDynamic: false  // não muda os valores de A e B
            },

            // 3) Operação OR
            {   shape: 'tetra', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),
                ev: function() { return this.A() ^ this.B(); }, // Cálculo real: A XOR B
                ab: true, expr: 'A⊕B',  // Exibição visual
                isDynamic: false  // não muda os valores de A e B
            },
                        
        
        // --- NÍVEL 5 (cruzadores, com expressão simples, com valor de A e B gerado aleatoriamente, mudando a cada "changeInterval" segundos)

            // 1) Operação AND
            {     shape: 'tetra', A: () => Math.round(Math.random()),  B: () => Math.round(Math.random()),
                  ev: function() { return this.A() & this.B(); }, // Cálculo real: A AND B
                  ab: true, expr: 'A.B', // Exibição visual
                  isDynamic: true, changeInterval: 5 
            },

            // 2) Operação OR
            {     shape: 'tetra', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),
                  ev: function() { return this.A() | this.B(); }, // Cálculo real: A OR B
                  ab: true, expr: 'A+B', // Exibição visual
                  isDynamic: true,  changeInterval: 5
            },

            // 3) Operação XOR
            {     shape: 'tetra', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),
                  ev: function() { return this.A() ^ this.B(); }, // Cálculo real: A XOR B
                  ab: true, expr: 'A⊕B', // Exibição visual
                  isDynamic: true,  changeInterval: 5 
            },

        
        // --- NÍVEL 6 (cruzadores, com expressões básicas, A fixo, B dinâmico = PSB ou !PSB), ambos mudando de tempos em tempos

            // 1) Operação AND            
            {   shape: 'tetra', 
                A: () => Math.round(Math.random()), // gerado aleatoriamente
                B: () => Math.random() > 0.5 ? playerPSB : 1 - playerPSB, // usa playerPSB para definição
                B: function() { return Math.random() > 0.5 ? playerPSB : 1 - playerPSB; },  // Recalcula sempre que chamada (dinâmico + reage ao playerPSB)
                ev: function() { return this.A() & this.B(); }, // Cálculo A.B
                ab: true, expr: 'A.B',   // Exibição visual
                isDynamic: true, changeInterval: 4   // muda os valores de A e B a cada 4 segundos
            },

            // 2) Operação OR 
            {   
                shape: 'tetra',
                A: () => Math.round(Math.random()), 
                B: function() { return Math.random() > 0.5 ? playerPSB : 1 - playerPSB; },  // Recalcula sempre que chamada (dinâmico + reage ao playerPSB)
                ev: function() { return this.A() | this.B(); }, // Cálculo A+B
                ab: true, expr: 'A+B', // Exibição visual
                isDynamic: true, changeInterval: 4   // muda os valores de A e B a cada 4 segundos
            },

            // 3) Operação XOR
            {   
                shape: 'tetra',
                A: () => Math.round(Math.random()), 
                B: function() { return Math.random() > 0.5 ? playerPSB : 1 - playerPSB; },  // Recalcula sempre que chamada (dinâmico + reage ao playerPSB)
                ev: function() { return this.A() ^ this.B(playerPSB); }, // Cálculo A⊕B
                ab: true, expr: 'A⊕B', // Exibição visual
                isDynamic: true, changeInterval: 4    // muda os valores de A e B a cada 4 segundos
            },
        
        // --- NÍVEL 7 (destroyers, com expressão complexas, com valor de A e B gerado aleatoriamente, que fica constante)
        
            // 1) (NOT A OR NOT B) → Lei de De Morgan equivalente a NAND
            { shape: 'octahedron', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),  // define nave, gera A e B de forma aleatória
              ev: function() { return (1 - this.A()) | (1 - this.B()); },  // Cálculo real
              ab: true, expr: '(!A)+(!B)', // Exibição visual
              isDynamic: false  // valores de A e B não mudam após serem gerados
            },
                    
            // 2) (NOT A AND NOT B) → Lei de De Morgan equivalente a NOR
            { shape: 'octahedron', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()), // define nave, gera A e B de forma aleatória
              ev: function() { return (1 - this.A()) & (1 - this.B()); },  // Cálculo real
              ab: true, expr: '(!A).(!B)', // Exibição visual
              isDynamic: false  // valores de A e B não mudam após serem gerados
            },
        
            // 3) (NOT A AND B) OR (NOT B AND A) → equivalente ao XOR de A e B            
            { shape: 'octahedron', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),  // define nave, gera A e B de forma aleatória                            
              ev: function() { return ((1 - this.A()) & this.B()) | (this.A() & (1 - this.B())); },  // cálculo real
              ab: true, expr: '(!A.B)+(A.!B)', // Exibição visual
              isDynamic: false  // valores de A e B não mudam após serem gerados
            },       

        // --- NÍVEL 8 (destroyers, com expressão complexas, com valor de A e B gerado aleatoriamente, mudando de tempos em tempos)
        
            // 1) (NOT A OR NOT B) → Lei de De Morgan equivalente a NAND
            { shape: 'octahedron', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),  // define nave, gera A e B de forma aleatória
              ev: function() { return (1 - this.A()) | (1 - this.B()); },  // Cálculo real
              ab: true, expr: '(!A)+(!B)', // Exibição visual
              isDynamic: true, changeInterval: 5     // muda os valores de A e B a cada 5 segundos
            },
                    
            // 2) (NOT A AND NOT B) → Lei de De Morgan equivalente a NOR
            { shape: 'octahedron', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()), // define nave, gera A e B de forma aleatória
              ev: function() { return (1 - this.A()) & (1 - this.B()); },  // Cálculo real
              ab: true, expr: '(!A).(!B)', // Exibição visual
              isDynamic: true, changeInterval: 5     // muda os valores de A e B a cada 5 segundos
            },
        
            // 3) (NOT A AND B) OR (NOT B AND A) → equivalente ao XOR de A e B            
            { shape: 'octahedron', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),  // define nave, gera A e B de forma aleatória              
              ev: function() { return ((1 - this.A()) & this.B()) | (this.A() & (1 - this.B())); },  // cálculo real
              ab: true, expr: '(!A.B)+(A.!B)', // Exibição visual
              isDynamic: true, changeInterval: 5     // muda os valores de A e B a cada 5 segundos
            },

        // --- NAVE-MÃE ---
            {
              shape: 'octahedron', size: 3.0,
              generators: [], // Inicializa vazio (será preenchido em spawnMothership())
              ev: function() {
                  if (this.generators.length === 0) return 0; // Segurança
                  const A = this.generators[0].value;
                  const B = this.generators[1].value;
                  return (A ^ B) & playerPSB;
              },
              expr: '(A⊕B).C',
              isBoss: true,
              health: 12 + maxWaves
            }
            
        ];

        // ===== [ CONSTANTES DE CORES E CONFIGURAÇÕES VISUAIS ] ===== //
        const PLAYER_COLOR = 0x0077ff;          // Cor azul do jogador (hexadecimal)
        const ENEMY_COLOR = 0xff3300;           // Cor vermelha dos inimigos
        const PROJECTILE_COLOR = 0xffffff;      // Cor branca dos projéteis do jogador
        const ENEMY_PROJECTILE_COLOR = 0xff2200;// Cor vermelha dos projéteis inimigos
        const STAR_COLOR = 0xffffff;            // Cor branca das estrelas de fundo
        const POWERUP_COLOR = 0x00ff00;         // Cor verde dos power-ups
        const BG_COLOR = 0x0a0e2a;              // Cor de fundo do espaço (azul escuro)
        const PLAY_AREA = { x: 16, y: 10 };     // Dimensões da área jogável (unidades 3D)
        
        // ===== [ VARIÁVEIS DE RENDERIZAÇÃO ] ===== //
        let renderer, scene, camera;            // Objetos principais do Three.js
        let width = window.innerWidth,          // Largura da janela
            height = window.innerHeight;        // Altura da janela
        
        // ===== [ ESTADO DO JOGO ] ===== //
        let gameState = GAME_STATE.START;       // Controla o estado atual (início/jogando/game over)
        
        // ===== [ VARIÁVEIS DO JOGADOR ] ===== //
        let player,                             // Objeto com posição/speed do jogador
            playerPSB = 1,                      // Valor lógico atual do jogador (0 ou 1)
            playerHealth = 5,                   // Vida atual
            playerMaxHealth = 5,                // Vida máxima
            playerScore = 0;                    // Pontuação
        
        // ===== [ OBJETOS 3D DO JOGADOR ] ===== //
        let playerShip,                         // Malha 3D da nave
            playerThruster,                     // Efeito de propulsão
            playerPSBMesh,                      // Sprite do valor lógico (PSB)
            playerHealthBar;                     // Barra de vida flutuante
        
        // ===== [ ARRAYS DE ENTIDADES ] ===== //
        let enemies = [],                       // Lista de inimigos ativos
            projectiles = [],                   // Projéteis do jogador
            enemyProjectiles = [],              // Projéteis inimigos
            explosions = [],                    // Efeitos de explosão
            powerUps = [];                      // Power-ups coletáveis
        
        // ===== [ CONTROLES E OPERADORES ] ===== //
        let operatorIndex = 0;                  // Índice do operador lógico selecionado
        
        // ===== [ SISTEMA DE BOMBAS ] ===== //
        const INITIAL_BOMB_COUNT = 15;          // Quantidade inicial de bombas (não usado diretamente)
        let bombCounts = {};                    // Contagem de bombas por operador (ex: { AND: 10 })
        let bombReplenishedAtScore = {};        // Pontuações que já deram recarga de bombas
        
        // ===== [ INPUT ] ===== //
        let keys = {};                          // Rastreia teclas pressionadas ({ KeyA: true/false })
        
        // ===== [ ELEMENTOS VISUAIS ] ===== //
        let stars = [];                         // Partículas de estrelas de fundo
        let hud = {};                           // Elementos de UI (health, score, etc)
        
        // ===== [ OVERLAYS DE TELA ] ===== //
        let pauseOverlay,                       // Tela de pausa
            startOverlay,                       // Tela inicial
            gameOverOverlay,                    // Tela de game over
            winOverlay;                         // Tela de vitória
        
        // ===== [ TIMERS ] ===== //
        let lastFire = 0,                       // Último momento que o jogador atirou
            fireDelay = 0.25;                   // Delay entre tiros (segundos)
        let lastEnemyFire = 0,                  // Último tiro inimigo
            enemyFireDelay = 1.5;               // Delay entre tiros inimigos
        let lastUpdate = performance.now();     // Timestamp da última atualização (para cálculo de deltaTime)
        

        // Inicializa os contadores de bombas
        function initBombCounts() {
            OPERATORS.forEach(op => {
                //bombCounts[op.key] = INITIAL_BOMB_COUNT;
                //bombReplenishedAtScore[op.key] = {};
                bombCounts = {
                    'AND': 10,
                    'OR': 8,
                    'XOR': 12,
                    'NAND': 8,
                    'NOR': 15,
                    'XNOR': 15
                };
                bombReplenishedAtScore = {};                
            });
        }
        
        function createRenderer() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setClearColor(BG_COLOR);
            renderer.setSize(width, height);
            document.body.appendChild(renderer.domElement);
        }

        function createCamera() {
            camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 100);
            camera.position.set(0, 0, 22);
        }

        function createScene() {
            scene = new THREE.Scene();
            let ambient = new THREE.AmbientLight(0xffffff, 0.7);
            let dir = new THREE.DirectionalLight(0xffffff, 0.8);
            dir.position.set(0, 0, 10);
            scene.add(ambient, dir);
        }

        function createStars() {
            for (let i = 0; i < 80; i++) {
                let geo = new THREE.SphereGeometry(Math.random() * 0.05 + 0.02, 6, 6);
                let mat = new THREE.MeshBasicMaterial({ color: STAR_COLOR });
                let mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(
                    (Math.random() - 0.5) * PLAY_AREA.x * 1.2,
                    (Math.random() - 0.5) * PLAY_AREA.y * 1.2,
                    -3 - Math.random() * 3
                );
                scene.add(mesh);
                stars.push(mesh);
            }
        }

        function createPlayer() {
            let geo = new THREE.ConeGeometry(0.6, 1.6, 5);
            let mat = new THREE.MeshLambertMaterial({ color: PLAYER_COLOR });
            playerShip = new THREE.Mesh(geo, mat);
            playerShip.rotation.z = Math.PI;
            playerShip.position.set(0, -PLAY_AREA.y / 2.2, 0);
            scene.add(playerShip);

            let thrusterGeo = new THREE.CylinderGeometry(0.18, 0.01, 0.4, 8);
            let thrusterMat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.7 });
            playerThruster = new THREE.Mesh(thrusterGeo, thrusterMat);
            playerThruster.position.set(0, -0.95, 0);
            playerThruster.rotation.x = Math.PI / 2;
            playerShip.add(playerThruster);

            playerHealthBar = createBar(1.5, 0.12, 0x00ff55, 0.2);
            playerHealthBar.position.set(0, 1.2, 0);
            playerShip.add(playerHealthBar);

            playerPSBMesh = createPSBMesh(playerPSB);
            playerPSBMesh.position.set(0, 1.7, 0);
            scene.add(playerPSBMesh);

            player = {
                x: 0,
                y: -PLAY_AREA.y / 2.2,
                speed: 7.5
            };
        }

        function createPSBMesh(val) {
            let canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            let ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 128, 128);
            ctx.font = 'bold 88px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = val ? '#0090ff' : '#ff2222';
            ctx.shadowBlur = 12;
            ctx.fillStyle = val ? '#0090ff' : '#ff2222';
            ctx.fillText(val ? '1' : '0', 64, 64);
            let tex = new THREE.CanvasTexture(canvas);
            let mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
            let sprite = new THREE.Sprite(mat);
            sprite.scale.set(0.9, 0.9, 1);
            sprite.psbValue = val;
            return sprite;
        }

        function updatePSBMesh(val) {
            let sprite = playerPSBMesh;
            let canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            let ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 128, 128);
            ctx.font = 'bold 88px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = val ? '#0090ff' : '#ff2222';
            ctx.shadowBlur = 12;
            ctx.fillStyle = val ? '#0090ff' : '#ff2222';
            ctx.fillText(val ? '1' : '0', 64, 64);
            sprite.material.map.image = canvas;
            sprite.material.map.needsUpdate = true;
            sprite.psbValue = val;
        }

        function createBar(w, h, color, border) {
            let group = new THREE.Group();
            let bgGeo = new THREE.PlaneGeometry(w + border, h + border);
            let bgMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
            let bg = new THREE.Mesh(bgGeo, bgMat);
            group.add(bg);
            let fgGeo = new THREE.PlaneGeometry(w, h);
            let fgMat = new THREE.MeshBasicMaterial({ color: color });
            let fg = new THREE.Mesh(fgGeo, fgMat);
            fg.position.z = 0.01;
            fg.name = 'bar';
            group.add(fg);
            return group;
        }

        function setBarValue(bar, frac) {
            let fg = bar.children.find(m => m.name === 'bar');
            fg.scale.x = Math.max(0.01, frac);
            fg.position.x = -(1 - frac) * (fg.geometry.parameters.width / 2);
        }

        
        function spawnEnemy(type, x, y) {
            let mesh;
        
            // ==================== [1. DEFINE VIDA POR TIPO DE NAVE] ====================
            let health;
            if (type.shape === 'cube') {  // Caças
                health = 2 + Math.floor(wave * 0.5);  // Wave 1 = 2 → ajustado para mínimo 3 abaixo
            } else if (type.shape === 'tetra') {  // Cruzadores
                health = 3 + Math.floor(wave * 0.7);  // Wave 5 = 6
            } else if (type.shape === 'octahedron') {  // Destroyers
                health = 4 + Math.floor(wave * 1.0);  // Wave 7 = 11
            }
            health = Math.max(health, 3);  // Garante vida mínima = 3
        
            // ==================== [2. CRIA GEOMETRIA] ====================
            if (type.shape === 'cube') {
                mesh = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 1, 1),
                    new THREE.MeshLambertMaterial({ color: ENEMY_COLOR })
                );
            } else if (type.shape === 'tetra') {
                mesh = new THREE.Mesh(
                    new THREE.TetrahedronGeometry(0.7),
                    new THREE.MeshLambertMaterial({ color: ENEMY_COLOR })
                );
            } else if (type.shape === 'octahedron') {
                mesh = new THREE.Mesh(
                    new THREE.OctahedronGeometry(0.8),
                    new THREE.MeshLambertMaterial({ 
                        color: ENEMY_COLOR,
                        emissive: 0xff3300,
                        emissiveIntensity: 0.3
                    })
                );
            }
            mesh.position.set(x, y, 0);
        
            // ==================== [3. ESTRUTURA DE DANO/EXIBIÇÃO] ====================
            let healthBar = createBar(1.1, 0.11, 0xff4444, 0.18);
            healthBar.position.set(0, -0.77, 0);
            mesh.add(healthBar);
        
            let ab = type.ab;
            let A = ab ? (type.A ? type.A() : Math.round(Math.random())) : null;
            let B = ab ? (type.B ? type.B() : Math.round(Math.random())) : null;
            let ev = type.ev ? type.ev() : (A !== null && B !== null ? eval(type.expr.replace('.', '&').replace('+', '|').replace('⊕', '^')) : null);
            let evText = type.expr || ev?.toString();
        
            let evMesh = createEVSprite(evText, A, B, type.expr);
            evMesh.position.set(0, 0.8, 0);
            mesh.add(evMesh);
            scene.add(mesh);
        
            return {
                mesh, health, maxHealth: health, healthBar, ev, evMesh, ab, A, B, expr: type.expr, alive: true, type
            };
        }

        function updateDynamicEnemies(dt) {
            for (let e of enemies) {
                if (!e.alive || !e.type.isDynamic) continue;
                
                e.changeTimer = (e.changeTimer || 0) + dt;
                if (e.changeTimer >= e.type.changeInterval) {
                    e.changeTimer = 0;
                    
                    // Atualiza A e B (se existirem)
                    if (e.type.A) e.A = e.type.A();
                    if (e.type.B) e.B = e.type.B(playerPSB); // Passa playerPSB para níveis como o 6
                    
                    // Recalcula ev (usando a expressão ou função ev)
                    e.ev = e.type.ev ? e.type.ev() : 
                          (e.A !== null && e.B !== null ? eval(e.expr.replace('.', '&').replace('+', '|').replace('⊕', '^')) : null);
                    
                    // Atualiza o sprite da expressão
                    updateEnemyEVSprite(e);
                }
            }
        }

        function updateEnemyEVSprite(enemy) {
            // Remove o sprite antigo
            enemy.mesh.remove(enemy.evMesh);
            
            // Cria um novo sprite com os valores atualizados
            let evText = enemy.expr || enemy.ev?.toString();
            enemy.evMesh = createEVSprite(evText, enemy.A, enemy.B, enemy.expr);
            enemy.evMesh.position.set(0, 0.8, 0);
            enemy.mesh.add(enemy.evMesh);
        }
        
        function spawnMothership() {
            const type = ENEMY_TYPES.find(t => t.isBoss);
            const mothership = spawnEnemy(type, 0, PLAY_AREA.y/2.5);                        
            mothership.mesh.scale.set(1.5, 1.5, 1.5);  // Expansão
            
            // Adiciona geradores
            mothership.generators = [ // Preenche os geradores aqui
                { label: 'A', value: Math.round(Math.random()) },
                { label: 'B', value: Math.round(Math.random()) }
            ];
            
            return mothership;
        }
                
        function updateMothership(dt) {
            if (!mothership || !mothership.alive) return;
        
            // Atualiza geradores A/B a cada 5 segundos
            mothership.changeTimer = (mothership.changeTimer || 0) + dt;
            if (mothership.changeTimer >= 5) {
                mothership.changeTimer = 0;
                mothership.generators[0].value = Math.round(Math.random()); // A
                mothership.generators[1].value = Math.round(Math.random()); // B
                mothership.ev = mothership.type.ev(); // Recalcula (A⊕B).C
                updateEnemyEVSprite(mothership); // Atualiza HUD
            }
        }
        
        function createEVSprite(text, A, B, expr) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 164;
            const ctx = canvas.getContext('2d');
        
            // Expressão (amarelo)
            ctx.font = 'bold 50px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = "#ffff55";
            ctx.shadowColor = '#000';
            ctx.shadowBlur = 8;
            ctx.fillText(text, 128, 40);
        
            // Fundo das variáveis (se existirem)
            if (A !== null && B !== null && expr) {
                ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                ctx.fillRect(50, 90, 156, 40);
                
                // Variáveis (verde)
                ctx.font = 'bold 32px Arial';
                ctx.fillStyle = "#55ff55";
                ctx.shadowBlur = 0;
                ctx.fillText(`A = ${A}  B = ${B}`, 128, 100);
            }
        
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(3.2, 2.0, 1);
            return sprite;
        }
        
        function spawnProjectile(x, y, dx, dy, operator) {            
            playSound('shoot');             
            let geo = new THREE.CylinderGeometry(0.15, 0.15, 0.7, 10);
            let mat = new THREE.MeshBasicMaterial({ color: PROJECTILE_COLOR, emissive: PROJECTILE_COLOR });
            //let mat = new THREE.MeshBasicMaterial({ color: PROJECTILE_COLOR }); // Removido emissive
            let mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = Math.PI / 2;
            mesh.position.set(x, y + 0.8, 0.05);
            scene.add(mesh);
            projectiles.push({ mesh, dx, dy, operator, alive: true });
        }

        function spawnEnemyProjectile(x, y, dx, dy) {
            let geo = new THREE.CylinderGeometry(0.14, 0.14, 0.5, 8);
            let mat = new THREE.MeshBasicMaterial({ color: ENEMY_PROJECTILE_COLOR });
            let mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = Math.PI / 2;
            mesh.position.set(x, y - 1.0, 0.05);
            scene.add(mesh);
            enemyProjectiles.push({ mesh, dx, dy, alive: true });
        }
        
        function spawnExplosion(x, y) {
            playSound('explosion');
            let group = [];
            for (let i = 0; i < 15; i++) {
                let geo = new THREE.SphereGeometry(0.13 + Math.random() * 0.09, 6, 6);
                let mat = new THREE.MeshBasicMaterial({ color: Math.random() < 0.5 ? 0xff3300 : 0xff9900 });
                let mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y, 0.1);
                mesh.dx = (Math.random() - 0.5) * 2.2;
                mesh.dy = (Math.random() - 0.5) * 2.2;
                mesh.ttl = 0.45 + Math.random() * 0.2;
                scene.add(mesh);
                group.push(mesh);
            }
            explosions.push({ group, time: 0 });
            
            // 30% chance de dropar power-up
            if (Math.random() < 0.3) {
                spawnPowerUp(x, y);
            }
        }

        function spawnPowerUp(x, y) {
            playSound('powerup')
            let geo = new THREE.SphereGeometry(0.3, 16, 16);
            let mat = new THREE.MeshBasicMaterial({ color: POWERUP_COLOR, emissive: POWERUP_COLOR });
            let mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, 0.1);
            scene.add(mesh);
            powerUps.push({
                mesh,
                alive: true,
                ttl: 8.0,
                dy: -1.0
            });
        }

        function resetGame() {
            while (scene.children.length) scene.remove(scene.children[0]);
            stars = [];
            enemies = [];
            projectiles = [];
            enemyProjectiles = [];
            explosions = [];
            powerUps = [];
            mothership = null;
            //bossGenerators = [];
            //bossHealth = 10;
            //bossB = 0;
            createStars();
            createPlayer();
            playerHealth = playerMaxHealth;
            playerScore = 0;
            wave = 1;
            operatorIndex = 0;
            playerPSB = 1;
            updatePSBMesh(playerPSB);
            lastFire = 0;
            lastEnemyFire = 0;
            waveEnemies = 0;
            initBombCounts();
            bombReplenishedAtScore = {};
        }

        function getEnemyType(wave, index) {
            
            // Waves 1-3: Níveis 1-3 puros
            if (wave === 1) return ENEMY_TYPES[0]; // Caças (nível 1)
            if (wave === 2) return ENEMY_TYPES[1]; // Caças dinâmicos (nível 2)
            if (wave === 3) return ENEMY_TYPES[2]; // Caças PSB (nível 3)
        
            // Wave 4: Mistura de níveis 1-3 (4:2:3)
            if (wave === 4) {
                const types = [0, 0, 0, 0, 1, 1, 2, 2, 2]; // Proporção 4:2:3
                return ENEMY_TYPES[types[index % types.length]];
            }
        
            // Wave 5: Cruzadores básicos (nível 4)
            if (wave === 5) return ENEMY_TYPES[3 + (index % 3)]; // AND, OR, XOR
        
            // Wave 6: Cruzadores dinâmicos (nível 5)
            if (wave === 6) return ENEMY_TYPES[6 + (index % 3)]; // AND, OR, XOR dinâmicos
        
            // Wave 7: Cruzadores A fixo + B = PSB (nível 6)
            if (wave === 7) return ENEMY_TYPES[9 + (index % 3)]; // AND, OR, XOR com B dinâmico
        
            // Wave 8: Mistura de níveis 1, 5, 7 (4:4:4)
            if (wave === 8) {
                const types = [0, 6, 9, 0, 7, 10, 0, 6, 9, 0, 7, 10]; // Proporção 4:4:4
                return ENEMY_TYPES[types[index % types.length]];
            }
        
            // Wave 9: Mistura de níveis 2, 3, 6, 8 (3:3:4:3)
            if (wave === 9) {
                const types = [1, 2, 9, 1, 2, 12, 1, 2, 9, 1, 2, 12, 9, 12]; // Proporção 3:3:4:3
                return ENEMY_TYPES[types[index % types.length]];
            }
        
            // Wave 10: Nave-mãe + escoltas (será implementada separadamente)
            return ENEMY_TYPES[0]; // Padrão (não deve ocorrer)
        }
        
        function startWave(n) {
            n = 10;
            // Wave 10: Nave-mãe + escoltas
            if (n === 10) {
                spawnMothership(); // Implemente essa função separadamente
                waveEnemies = 1; // Conta apenas a nave-mãe (escoltas são extras)
                return;
            }
        
            // Waves 1-9: Inimigos normais
            let nEnemies;
            if (n === 3) {
                nEnemies = 5; // Wave 3 tem 5 inimigos
            } else if (n >= 8) {
                nEnemies = 10; // Waves 8-9 têm mais inimigos
            } else {
                nEnemies = Math.min(4 + n, 7); // Waves 1-2,4-7: 4 a 7 inimigos
            }
            
            waveEnemies = nEnemies;
        
            for (let i = 0; i < nEnemies; i++) {
                let type = getEnemyType(n, i);
                let x = -PLAY_AREA.x / 2 + 1.5 + (i % nEnemies) * (PLAY_AREA.x - 3) / (nEnemies - 1);
                let y = PLAY_AREA.y / 2 - 1.5 - Math.random() * 1.4;
                enemies.push(spawnEnemy(type, x, y));
            }
        }
        
        function updateHUD() {
            if (!hud.health) {
                hud.health = document.createElement('div');
                hud.health.style.position = 'fixed';
                hud.health.style.left = '18px';
                hud.health.style.top = '12px';
                hud.health.style.color = '#00ff88';
                hud.health.style.font = 'bold 22px monospace';
                hud.health.style.textShadow = '0 0 5px #003';
                document.body.appendChild(hud.health);
            }
            hud.health.innerHTML = 'Health: ' + playerHealth;
            
            if (!hud.score) {
                hud.score = document.createElement('div');
                hud.score.style.position = 'fixed';
                hud.score.style.right = '18px';
                hud.score.style.top = '12px';
                hud.score.style.color = '#fff';
                hud.score.style.font = 'bold 22px monospace';
                hud.score.style.textShadow = '0 0 5px #003';
                document.body.appendChild(hud.score);
            }
            hud.score.innerHTML = 'Pontuação: ' + playerScore;
            
            if (!hud.psb) {
                hud.psb = document.createElement('div');
                hud.psb.style.position = 'fixed';
                hud.psb.style.left = '18px';
                hud.psb.style.bottom = '18px';
                hud.psb.style.color = '#fff';
                hud.psb.style.font = 'bold 32px monospace';
                hud.psb.style.textShadow = '0 0 8px #0077ff';
                document.body.appendChild(hud.psb);
            }
            hud.psb.innerHTML = 'PSB: <span style="color:' + (playerPSB ? '#0090ff' : '#ff2222') + '">' + playerPSB + '</span>';
            
            if (!hud.op) {
                hud.op = document.createElement('div');
                hud.op.style.position = 'fixed';
                hud.op.style.bottom = '18px';
                hud.op.style.left = '50%';
                hud.op.style.transform = 'translateX(-50%)';
                hud.op.style.color = '#fff';
                hud.op.style.font = 'bold 28px monospace';
                hud.op.style.textShadow = '0 0 8px #fff';
                document.body.appendChild(hud.op);
            }
            const currentOperatorKey = OPERATORS[operatorIndex].key;          
            hud.op.innerHTML = 'Operador: <span style="color:#fff;background:#222;padding:2px 10px;border-radius:7px;">' + 
                   OPERATORS[operatorIndex].key + '</span>' +
                   ' <span style="color:#00ff88;font-size:22px;">(' + bombCounts[OPERATORS[operatorIndex].key] + ')</span>';
            
            if (!hud.wave) {
                hud.wave = document.createElement('div');
                hud.wave.style.position = 'fixed';
                hud.wave.style.top = '12px';
                hud.wave.style.left = '50%';
                hud.wave.style.transform = 'translateX(-50%)';
                hud.wave.style.color = '#fff';
                hud.wave.style.font = 'bold 22px monospace';
                hud.wave.style.textShadow = '0 0 7px #0077ff';
                document.body.appendChild(hud.wave);
            }
            if (gameState === GAME_STATE.PLAYING && !mothership)
                hud.wave.innerHTML = 'Fase ' + wave + ' de ' + maxWaves;
            else if (mothership && gameState === GAME_STATE.PLAYING)
                hud.wave.innerHTML = 'Nave-Mãe';
            else
                hud.wave.innerHTML = '';

          // Exibe geradores da nave-mãe (se estiver ativa)
            if (mothership && mothership.alive) {
                if (!hud.bossGens) {
                    hud.bossGens = document.createElement('div');
                    hud.bossGens.style.position = 'fixed';
                    hud.bossGens.style.top = '50px';
                    hud.bossGens.style.left = '50%';
                    hud.bossGens.style.transform = 'translateX(-50%)';
                    hud.bossGens.style.color = '#ff5555';
                    hud.bossGens.style.font = 'bold 18px monospace';
                    hud.bossGens.style.textShadow = '0 0 5px #000';
                    document.body.appendChild(hud.bossGens);
                }
                hud.bossGens.innerHTML = `Geradores: A=${mothership.generators[0].value} | B=${mothership.generators[1].value}`;
            } else if (hud.bossGens) {
                hud.bossGens.innerHTML = '';
            }
        }

        function clearHUD() {
            for (let k in hud) {
                if (hud[k] && hud[k].parentNode) hud[k].parentNode.removeChild(hud[k]);
                hud[k] = null;
            }
        }

        function showOverlay(type, text, subtext) {
            let overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.left = '0';
            overlay.style.top = '0';
            overlay.style.width = '100vw';
            overlay.style.height = '100vh';
            overlay.style.background = 'rgba(10,14,42,0.93)';
            overlay.style.display = 'flex';
            overlay.style.flexDirection = 'column';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '1000';
            overlay.style.fontFamily = 'monospace';
            let title = document.createElement('div');
            title.style.fontSize = '58px';
            title.style.color = '#fff';
            title.style.textShadow = '0 0 24px #0077ff, 0 0 12px #fff';
            title.style.fontWeight = 'bold';
            title.style.letterSpacing = '2px';
            title.innerHTML = text;
            overlay.appendChild(title);
            if (subtext) {
                let st = document.createElement('div');
                st.style.fontSize = '28px';
                st.style.color = '#fff';
                st.style.marginTop = '28px';
                st.style.textShadow = '0 0 8px #0077ff';
                st.innerHTML = subtext;
                overlay.appendChild(st);
            }
            document.body.appendChild(overlay);
            return overlay;
        }

        function removeOverlay(overlay) {
            if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
        }

        function keyDown(e) {
            if (e.repeat) return;
            keys[e.code] = true;

          // Adicionar Tecla C para Alternar PSB (NOT) 
            if (e.code === 'KeyC') { // Tecla C inverte o PSB
                playerPSB = 1 - playerPSB;
                updatePSBMesh(playerPSB);
                return; // Evita conflito com outras ações
            }
            
            if (gameState === GAME_STATE.START && e.code === 'Space') {
                removeOverlay(startOverlay);
                resetGame();
                gameState = GAME_STATE.PLAYING;
                startWave(wave);
            } else if (gameState === GAME_STATE.GAME_OVER && e.code === 'Space') {
                removeOverlay(gameOverOverlay);
                clearHUD();
                gameState = GAME_STATE.START;
                startOverlay = showOverlay('start', 'O Último Guerreiro Digital das Estrelas', '<span style="font-size:22px;">Tecle ESPAÇO para iniciar</span>');
            } else if (gameState === GAME_STATE.WIN && e.code === 'Space') {
                removeOverlay(winOverlay);
                clearHUD();
                gameState = GAME_STATE.START;
                startOverlay = showOverlay('start', 'O Último Guerreiro Digital das Estrelas', '<span style="font-size:22px;">Tecle ESPAÇO para iniciar</span>');
            } else if (gameState === GAME_STATE.PLAYING) {
                if (e.code === 'KeyP') {
                    if (pauseOverlay) {
                        removeOverlay(pauseOverlay);
                        pauseOverlay = null;
                        gameState = GAME_STATE.PLAYING;
                    } else {
                        pauseOverlay = showOverlay('pause', 'Paused', '<span style="font-size:22px;">Tecle P para retomar</span>');
                        gameState = GAME_STATE.PAUSED;
                    }
                }
                if (e.code === 'Tab') {
                    operatorIndex = (operatorIndex + 1) % OPERATORS.length;
                    e.preventDefault();
                }
                if (e.code === 'Space') {
                    //if (OPERATORS[operatorIndex].key === 'NOT') {
                    //    playerPSB = 1 - playerPSB;
                    //    updatePSBMesh(playerPSB);
                    //} else 
                    //{
                    
                        let now = performance.now() / 1000;
                        const currentOperatorKey = OPERATORS[operatorIndex].key;
                        if (bombCounts[currentOperatorKey] > 0 && now - lastFire > fireDelay) {
                            fireProjectile();
                            bombCounts[currentOperatorKey]--;
                            lastFire = now;
                        }
                    //}
                }
            } else if (gameState === GAME_STATE.PAUSED) {
                if (e.code === 'KeyP') {
                    removeOverlay(pauseOverlay);
                    pauseOverlay = null;
                    gameState = GAME_STATE.PLAYING;
                }
            }

        }

        function keyUp(e) {
            keys[e.code] = false;
        }

        function fireProjectile() {
            let target = null, minDist = 1000;
            for (let e of enemies) {
                if (!e.alive) continue;
                let dx = e.mesh.position.x - player.x;
                let dy = e.mesh.position.y - player.y;
                let d = dx * dx + dy * dy;
                if (d < minDist) {
                    minDist = d;
                    target = e;
                }
            }
            if (mothership && mothership.alive) {
                let dx = mothership.mesh.position.x - player.x;
                let dy = mothership.mesh.position.y - player.y;
                let d = dx * dx + dy * dy;
                if (d < minDist) {
                    minDist = d;
                    target = mothership;
                }
            }
            if (!target) return;
            let dx = target.mesh.position.x - player.x;
            let dy = target.mesh.position.y - player.y;
            let mag = Math.sqrt(dx * dx + dy * dy);
            if (mag === 0) mag = 1;
            dx /= mag; dy /= mag;
            spawnProjectile(player.x, player.y, dx * 13, dy * 13, operatorIndex);
        }

        function enemyFireLogic(dt) {
            let now = performance.now() / 1000;
            if (now - lastEnemyFire > enemyFireDelay) {
                for (let e of enemies) {
                    if (!e.alive) continue;
                    let dx = player.x - e.mesh.position.x;
                    let dy = player.y - e.mesh.position.y;
                    let mag = Math.sqrt(dx * dx + dy * dy);
                    if (mag === 0) mag = 1;
                    dx /= mag; dy /= mag;
                    if (Math.random() < 0.7)
                        spawnEnemyProjectile(e.mesh.position.x, e.mesh.position.y, dx * 7, dy * 7);
                }
                if (mothership && mothership.alive && Math.random() < 0.8) {
                    let dx = player.x - mothership.mesh.position.x;
                    let dy = player.y - mothership.mesh.position.y;
                    let mag = Math.sqrt(dx * dx + dy * dy);
                    if (mag === 0) mag = 1;
                    dx /= mag; dy /= mag;
                    spawnEnemyProjectile(mothership.mesh.position.x, mothership.mesh.position.y - 0.6, dx * 8, dy * 8);
                }
                lastEnemyFire = now;
            }
        }

        function updateProjectiles(dt) {
            for (let p of projectiles) {
                if (!p.alive) continue;
                p.mesh.position.x += p.dx * dt;
                p.mesh.position.y += p.dy * dt;
                if (Math.abs(p.mesh.position.x) > PLAY_AREA.x / 2 + 2 || Math.abs(p.mesh.position.y) > PLAY_AREA.y / 2 + 2) {
                    scene.remove(p.mesh);
                    p.alive = false;
                    continue;
                }
                for (let e of enemies) {
                    if (!e.alive) continue;
                    let ex = e.mesh.position.x, ey = e.mesh.position.y;
                    let px = p.mesh.position.x, py = p.mesh.position.y;
                    let dist = Math.sqrt((ex - px) ** 2 + (ey - py) ** 2);
                    if (dist < 0.8) {
                        let op = OPERATORS[p.operator];
                        let psb = playerPSB;
                        let ev = e.ev;
                        if (e.expr) {
                            if (e.expr === 'A&B') ev = e.A & e.B;
                            if (e.expr === 'A|B') ev = e.A | e.B;
                            if (e.expr === 'A^B') ev = e.A ^ B;
                        }
                        let result = op.fn(psb, ev);
                        if (result === 1) {
                            e.health--;
                            setBarValue(e.healthBar, e.health / e.maxHealth);
                            if (e.health <= 0) {
                                e.alive = false;
                                scene.remove(e.mesh);
                                spawnExplosion(ex, ey);
                                playerScore += 100;
                                waveEnemies--;
                            }
                        }
                        scene.remove(p.mesh);
                        p.alive = false;
                        break;
                    }
                }
                if (mothership && mothership.alive) {  
                    let ex = mothership.mesh.position.x, ey = mothership.mesh.position.y;  
                    let px = p.mesh.position.x, py = p.mesh.position.y;  
                    let dist = Math.sqrt((ex - px) ** 2 + (ey - py) ** 2);  
                    
                    if (dist < 1.5) {  
                        let op = OPERATORS[p.operator];  
                        let A = mothership.generators[0].value;  
                        let B = mothership.generators[1].value;  
                        let C = playerPSB;  
                        let expected = (A ^ B) & C; // (A⊕B).C  
                        let result = op.fn(C, (A ^ B)); // Aplica operador do jogador  
                        
                        if (result === expected && result === 1) {  
                            mothership.health--;  
                            setBarValue(mothership.healthBar, mothership.health / mothership.maxHealth);  
                            if (mothership.health <= 0) {  
                                mothership.alive = false;  
                                scene.remove(mothership.mesh);  
                                spawnExplosion(ex, ey);  
                                playerScore += 1000; // Pontuação maior para a nave-mãe  
                            }  
                        }  
                        scene.remove(p.mesh);  
                        p.alive = false;  
                    }  
                }  
                
            }
            projectiles = projectiles.filter(p => p.alive);
        }

        function updateEnemyProjectiles(dt) {
            for (let p of enemyProjectiles) {
                if (!p.alive) continue;
                p.mesh.position.x += p.dx * dt;
                p.mesh.position.y += p.dy * dt;
                if (Math.abs(p.mesh.position.x) > PLAY_AREA.x / 2 + 2 || Math.abs(p.mesh.position.y) > PLAY_AREA.y / 2 + 2) {
                    scene.remove(p.mesh);
                    p.alive = false;
                    continue;
                }
                let px = p.mesh.position.x, py = p.mesh.position.y;
                let dist = Math.sqrt((player.x - px) ** 2 + (player.y - py) ** 2);
                if (dist < 0.7) {
                    scene.remove(p.mesh);
                    p.alive = false;
                    playerHealth--;
                    setBarValue(playerHealthBar, playerHealth / playerMaxHealth);
                    if (playerHealth <= 0) {
                        gameState = GAME_STATE.GAME_OVER;
                        playSound('gameOver');                        
                        gameOverOverlay = showOverlay('gameover', 'GAME OVER', 'Pontuação: ' + playerScore + '<br><br>Tecle ESPAÇO para reiniciar');
                    }
                }
            }
            enemyProjectiles = enemyProjectiles.filter(p => p.alive);
        }

        function updateExplosions(dt) {
            for (let e of explosions) {
                for (let m of e.group) {
                    m.position.x += m.dx * dt;
                    m.position.y += m.dy * dt;
                    m.ttl -= dt;
                    if (m.ttl < 0) {
                        scene.remove(m);
                    }
                }
            }
            explosions = explosions.filter(e => e.group.some(m => m.ttl > 0));
        }

        function updatePowerUps(dt) {
            for (let pu of powerUps) {
                if (!pu.alive) continue;
                pu.mesh.position.y += pu.dy * dt;
                pu.ttl -= dt;
                if (pu.ttl < 0 || pu.mesh.position.y < -PLAY_AREA.y / 2 - 1) {
                    scene.remove(pu.mesh);
                    pu.alive = false;
                    continue;
                }
                let dist = Math.sqrt((player.x - pu.mesh.position.x) ** 2 + (player.y - pu.mesh.position.y) ** 2);
                if (dist < 1.0) {
                    playSound('powerupCollect');
                    //for (let key in bombCounts) {
                    //    bombCounts[key] = Math.min(bombCounts[key] + 5, INITIAL_BOMB_COUNT * 2);
                    //}
                    for (let key in bombCounts) {
                        if (key === 'OR' || key === 'NAND') {
                            bombCounts[key] = Math.min(bombCounts[key] + 3, 20); // Limite máximo de 20
                        } else if (key === 'NOR') {
                            bombCounts[key] = Math.min(bombCounts[key] + 5, 20);
                        } else {
                            bombCounts[key] = Math.min(bombCounts[key] + 4, 20);
                        }
                    }
                    scene.remove(pu.mesh);
                    pu.alive = false;
                    
                    // Efeito visual ao coletar
                    let particles = [];
                    for (let i = 0; i < 20; i++) {
                        let geo = new THREE.SphereGeometry(0.1, 6, 6);
                        let mat = new THREE.MeshBasicMaterial({ color: POWERUP_COLOR });
                        let mesh = new THREE.Mesh(geo, mat);
                        mesh.position.set(pu.mesh.position.x, pu.mesh.position.y, 0.1);
                        mesh.dx = (Math.random() - 0.5) * 3;
                        mesh.dy = (Math.random() - 0.5) * 3;
                        mesh.ttl = 0.8 + Math.random() * 0.4;
                        scene.add(mesh);
                        particles.push(mesh);
                    }
                    explosions.push({ group: particles, time: 0 });
                }
            }
            powerUps = powerUps.filter(pu => pu.alive);
        }

        function checkScoreForBombReplenish() {
            const scoreThresholds = [500, 1500, 3000, 5000, 8000];
            for (const threshold of scoreThresholds) {
                if (playerScore >= threshold && !bombReplenishedAtScore[threshold]) {
                    for (let key in bombCounts) {
                        bombCounts[key] = Math.min(bombCounts[key] + 10, INITIAL_BOMB_COUNT * 2);
                    }
                    bombReplenishedAtScore[threshold] = true;
                    break;
                }
            }
        }

        function updatePlayer(dt) {
            let moveX = 0, moveY = 0;
            if (keys['KeyA'] || keys['ArrowLeft']) moveX -= 1;
            if (keys['KeyD'] || keys['ArrowRight']) moveX += 1;
            if (keys['KeyW'] || keys['ArrowUp']) moveY += 1;
            if (keys['KeyS'] || keys['ArrowDown']) moveY -= 1;
            let mag = Math.sqrt(moveX * moveX + moveY * moveY);
            if (mag > 0) {
                moveX /= mag; moveY /= mag;
                player.x += moveX * player.speed * dt;
                player.y += moveY * player.speed * dt;
                player.x = Math.max(-PLAY_AREA.x / 2 + 0.8, Math.min(PLAY_AREA.x / 2 - 0.8, player.x));
                player.y = Math.max(-PLAY_AREA.y / 2 + 0.7, Math.min(PLAY_AREA.y / 2 - 0.7, player.y));
                playerShip.position.set(player.x, player.y, 0);
                playerPSBMesh.position.set(player.x, player.y + 1.7, 0);
            }
            playerThruster.material.opacity = 0.7 + 0.2 * Math.abs(Math.sin(performance.now() / 110));
        }

        function gameLoop() {
            let now = performance.now();
            let dt = Math.min((now - lastUpdate) / 1000, 0.045);
            lastUpdate = now;
            if (gameState === GAME_STATE.PLAYING) {
                updatePlayer(dt);
                updateProjectiles(dt);
                updateEnemyProjectiles(dt);
                updateExplosions(dt);
                updatePowerUps(dt);
                enemyFireLogic(dt);
                updateMothership(dt); // Adicionada esta linha para atualizar a nave-mãe
                
                for (let e of enemies) {
                    if (!e.alive) continue;
                    let t = Math.sin(now / 800 + e.mesh.position.x * 0.7) * 0.7;
                    e.mesh.position.y += Math.sin(now / 1300 + e.mesh.position.x * 0.5) * 0.3 * dt;
                    e.mesh.position.x += t * dt * 0.25;
                }
                
                if (waveEnemies === 0 && !mothership && wave <= maxWaves) {
                    if (wave === maxWaves) {
                        spawnMothership();
                        waveEnemies = 1;
                    } else {
                        wave++;
                        startWave(wave);
                    }
                }
                
                if (mothership && !mothership.alive && gameState === GAME_STATE.PLAYING) {
                    gameState = GAME_STATE.WIN;
                    playSound('victory');                    
                    winOverlay = showOverlay('win', 'VITÓRIA! VOCÊ ANIQUILOU A ARMADA KODAN!', 'Pontuação: ' + playerScore + '<br><br>Tecle ESPAÇO para reiniciar');
                }
                
                checkScoreForBombReplenish();
                updateHUD();
            }
            renderer.render(scene, camera);
            requestAnimationFrame(gameLoop);
        }

        // Inicialização do jogo
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });

        window.addEventListener('keydown', keyDown);
        window.addEventListener('keyup', keyUp);

        createRenderer();
        createCamera();
        createScene();
        initBombCounts();
        startOverlay = showOverlay('start', 'O Último Guerreiro Digital das Estrelas', '<span style="font-size:22px;">Tecle ESPAÇO para iniciar</span>');
        gameLoop();
    </script>
</body>
</html>
