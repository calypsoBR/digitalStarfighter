<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>O Último Guerreiro Digital das Estrelas</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }        
    </style>
</head>
<body>

   <button id="unmute" style="position:fixed; top:10px; left:10px; z-index:10000; padding:8px 15px; background:#0077ff; color:white; border:none; border-radius:5px; cursor:pointer;">
        CLIQUE AQUI PARA ATIVAR SOM
    </button>

    
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script>    

         // ===== [SEÇÃO DE SONS DO JOGO] ===== //
            let audioEnabled = false;
            const sounds = {
               // do jogador
                shoot: new Audio('./sounds/shoot.mp3'),
                lowHealth: new Audio('./sounds/low_health2.mp3'),
                booleanShield: new Audio('./sounds/boolean_shield.mp3'),
                lifeBonus: new Audio('./sounds/life_bonus.mp3'),
                playerHit: new Audio('./sounds/player_hit.mp3'),
                powerupCollect: new Audio('./sounds/powerup_collect.mp3'),
                
               // dos inimigos                 
                explosion: new Audio('./sounds/explosion.mp3'),
                powerup: new Audio('./sounds/powerup.mp3'),

               // Canhão Quine
                quineCannon: new Audio('./sounds/quine_cannon.mp3'),

               // Nave mãe
                
               // do jogo  
                gameOver: new Audio('./sounds/game_over2.mp3'),
                victory: new Audio('./sounds/victory.mp3')                
                
            };

            // volume dos sons: 20% do total 
            Object.values(sounds).forEach(audio => { audio.volume = 0.2; });  
        
            // Adiciona preload a todos os sons:
            Object.values(sounds).forEach(audio => {
                audio.preload = "auto"; // ✅ Garante carregamento antecipado
            });

        
            function enableAudio() {
                // Ativa o flag global que permite tocar sons no jogo
                audioEnabled = true;  
                // Tenta reproduzir todos os sons (para desbloquear autoplay), mas ignora erros
                Object.values(sounds).forEach(audio => {
                    audio.play().catch(() => {}); // Silencia erros intencionais (ex: bloqueio de autoplay)
                });
            }
                    
            function playSound(name) {                
                // Se o áudio estiver desativado ou não existir, sai da função sem fazer nada
                if (!audioEnabled || !sounds[name]) return;
                // define variável para não ficar chamando sounds várias vezes
                const audio = sounds[name]; 
                // Reinicia apenas se necessário (opcional)
                audio.currentTime = 0; 
                // Silencia erros de autoplay/intencionais
                audio.play().catch(() => {}); 
            }
        
            document.getElementById('unmute').addEventListener('click', () => {
                enableAudio();
                document.getElementById('unmute').style.display = 'none';
            });            
        
         // ===== [FIM DA SEÇÃO DE SONS] ===== //
             
        
        // ===== [DEFINIÇÃO DOS ESTADOS DO JOGO] ===== //
        const GAME_STATE = {
            START: 0,      // Estado inicial (tela de título)
            PLAYING: 1,    // Jogo em andamento
            PAUSED: 2,     // Jogo pausado
            GAME_OVER: 3,  // Derrota (exibindo tela de game over)
            WIN: 4         // Vitória (inimigos derrotados)
        };

        // ===== [CONTROLE DE WAVES/FASES] ===== //
        let wave = 1,       // Fase atual (começa na wave 1)
            maxWaves = 10,  // Número total de waves (última é a nave-mãe com escolta)
            waveEnemies = 0; // Contador de inimigos restantes na wave atual

        // ===== [ TIPOS DE "BOMBAS" (OPERADORES LÓGICOS)  ] ===== //         
        const OPERATORS = [
            { key: 'AND', fn: (a, b) => a & b },
            { key: 'OR', fn: (a, b) => a | b },
            { key: 'XOR', fn: (a, b) => a ^ b },           
            { key: 'NAND', fn: (a, b) => 1 - (a & b) },
            { key: 'NOR', fn: (a, b) => 1 - (a | b) },
            { key: 'XNOR', fn: (a, b) => 1 - (a ^ b) }
        ];

        // ===== [ TIPOS DE INIMIGOS (NAVES E SUAS CARACTERÍSTICAS) ] ===== //
        const ENEMY_TYPES = [
            
        // --- NÍVEL 1 (caças, com valor lógico constante, gearado aleatoriamente)
            
            {   shape: 'cube', ev: () => Math.round(Math.random()),   // define nave, gera valor lógico de forma aleatória
                isDynamic: false  // valor não muda após ser gerado
            },

            
        // --- NÍVEL 2 (caças, com valor mudando a cada "changeInterval" segundos, gearado aleatoriamente)
            
            {   shape: 'cube', ev: () => Math.round(Math.random()),  // define nave, gera valor lógico de forma aleatória
                isDynamic: true, changeInterval: 3  // muda o valor a cada 3 segundos
            },

            
         // --- NÍVEL 3 (caças, com valor mudando a cada "changeInterval" segundos, condicionado ao PSB ou seu contraditório)
                        
            {
                shape: 'cube',  // define nave,
                ev: function() { 
                    const psb = getSafePSB(); // <-- Usa a função segura
                    return Math.random() > 0.5 ? psb : 1 - psb;  //gera valor com 50% de chance de ser psb ou !psb
                },
                isDynamic: true, changeInterval: 4  // muda o valor a cada 4 segundos
            },

            
        // --- NÍVEL 4 (cruzadores, com expressão básicas, com valor de A e B constante, gerados aleatoriamente)

            // 1) Operação AND
            {     shape: 'tetra', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),
                  ev: function() { return this.A() & this.B(); },  // Cálculo real: A AND B
                  ab: true, expr: 'A.B', // Exibição visual
                  isDynamic: false  // não muda os valores de A e B
            },

            // 2) Operação OR
            {   shape: 'tetra', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),
                ev: function() { return this.A() | this.B(); }, // Cálculo real: A OR B
                ab: true, expr: 'A+B', // Exibição visual
                isDynamic: false  // não muda os valores de A e B
            },

            // 3) Operação OR
            {   shape: 'tetra', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),
                ev: function() { return this.A() ^ this.B(); }, // Cálculo real: A XOR B
                ab: true, expr: 'A⊕B',  // Exibição visual
                isDynamic: false  // não muda os valores de A e B
            },
                        
        
        // --- NÍVEL 5 (cruzadores, com expressão simples, com valor de A e B gerado aleatoriamente, mudando a cada "changeInterval" segundos)

            // 1) Operação AND
            {     shape: 'tetra', A: () => Math.round(Math.random()),  B: () => Math.round(Math.random()),
                  ev: function() { return this.A() & this.B(); }, // Cálculo real: A AND B
                  ab: true, expr: 'A.B', // Exibição visual
                  isDynamic: true, changeInterval: 5 
            },

            // 2) Operação OR
            {     shape: 'tetra', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),
                  ev: function() { return this.A() | this.B(); }, // Cálculo real: A OR B
                  ab: true, expr: 'A+B', // Exibição visual
                  isDynamic: true,  changeInterval: 5
            },

            // 3) Operação XOR
            {     shape: 'tetra', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),
                  ev: function() { return this.A() ^ this.B(); }, // Cálculo real: A XOR B
                  ab: true, expr: 'A⊕B', // Exibição visual
                  isDynamic: true,  changeInterval: 5 
            },

        
        // --- NÍVEL 6 (cruzadores, com expressões básicas, A fixo, B dinâmico = PSB ou !PSB), ambos mudando de tempos em tempos

            // 1) Operação AND            
            {   shape: 'tetra', 
                A: () => Math.round(Math.random()), // gerado aleatoriamente                
                B: function() { 
                    return Math.random() > 0.5 ? getSafePSB() : 1 - getSafePSB(); // Recalcula sempre que chamada (dinâmico + reage ao playerPSB)
                },
                ev: function() { return this.A() & this.B(); }, // Cálculo A.B
                ab: true, expr: 'A.B',   // Exibição visual
                isDynamic: true, changeInterval: 4   // muda os valores de A e B a cada 4 segundos
            },

            // 2) Operação OR 
            {   
                shape: 'tetra',
                A: () => Math.round(Math.random()), 
                B: function() { 
                    return Math.random() > 0.5 ? getSafePSB() : 1 - getSafePSB(); // Recalcula sempre que chamada (dinâmico + reage ao playerPSB)
                },
                ev: function() { return this.A() | this.B(); }, // Cálculo A+B
                ab: true, expr: 'A+B', // Exibição visual
                isDynamic: true, changeInterval: 4   // muda os valores de A e B a cada 4 segundos
            },

            // 3) Operação XOR
            {   
                shape: 'tetra',
                A: () => Math.round(Math.random()),                
                B: function() { 
                    return Math.random() > 0.5 ? getSafePSB() : 1 - getSafePSB(); // Recalcula sempre que chamada (dinâmico + reage ao playerPSB)
                },
                ev: function() { return this.A() ^ this.B(playerPSB); }, // Cálculo A⊕B
                ab: true, expr: 'A⊕B', // Exibição visual
                isDynamic: true, changeInterval: 4    // muda os valores de A e B a cada 4 segundos
            },
        
        // --- NÍVEL 7 (destroyers, com expressão complexas, com valor de A e B gerado aleatoriamente, que fica constante)
        
            // 1) (NOT A OR NOT B) → Lei de De Morgan equivalente a NAND
            { shape: 'octahedron', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),  // define nave, gera A e B de forma aleatória
              ev: function() { return (1 - this.A()) | (1 - this.B()); },  // Cálculo real
              ab: true, expr: '(!A)+(!B)', // Exibição visual
              isDynamic: false  // valores de A e B não mudam após serem gerados
            },
                    
            // 2) (NOT A AND NOT B) → Lei de De Morgan equivalente a NOR
            { shape: 'octahedron', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()), // define nave, gera A e B de forma aleatória
              ev: function() { return (1 - this.A()) & (1 - this.B()); },  // Cálculo real
              ab: true, expr: '(!A).(!B)', // Exibição visual
              isDynamic: false  // valores de A e B não mudam após serem gerados
            },
        
            // 3) (NOT A AND B) OR (NOT B AND A) → equivalente ao XOR de A e B            
            { shape: 'octahedron', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),  // define nave, gera A e B de forma aleatória                            
              ev: function() { return ((1 - this.A()) & this.B()) | (this.A() & (1 - this.B())); },  // cálculo real
              ab: true, expr: '(!A.B)+(A.!B)', // Exibição visual
              isDynamic: false  // valores de A e B não mudam após serem gerados
            },       

        // --- NÍVEL 8 (destroyers, com expressão complexas, com valor de A e B gerado aleatoriamente, mudando de tempos em tempos)
        
            // 1) (NOT A OR NOT B) → Lei de De Morgan equivalente a NAND
            { shape: 'octahedron', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),  // define nave, gera A e B de forma aleatória
              ev: function() { return (1 - this.A()) | (1 - this.B()); },  // Cálculo real
              ab: true, expr: '(!A)+(!B)', // Exibição visual
              isDynamic: true, changeInterval: 5     // muda os valores de A e B a cada 5 segundos
            },
                    
            // 2) (NOT A AND NOT B) → Lei de De Morgan equivalente a NOR
            { shape: 'octahedron', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()), // define nave, gera A e B de forma aleatória
              ev: function() { return (1 - this.A()) & (1 - this.B()); },  // Cálculo real
              ab: true, expr: '(!A).(!B)', // Exibição visual
              isDynamic: true, changeInterval: 5     // muda os valores de A e B a cada 5 segundos
            },
        
            // 3) (NOT A AND B) OR (NOT B AND A) → equivalente ao XOR de A e B            
            { shape: 'octahedron', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),  // define nave, gera A e B de forma aleatória              
              ev: function() { return ((1 - this.A()) & this.B()) | (this.A() & (1 - this.B())); },  // cálculo real
              ab: true, expr: '(!A.B)+(A.!B)', // Exibição visual
              isDynamic: true, changeInterval: 5     // muda os valores de A e B a cada 5 segundos
            },

        // --- NAVE-MÃE ---
            {
              shape: 'octahedron', size: 3.0,
              generators: [], // Inicializa vazio (será preenchido em spawnMothership())
              ev: function() {          
                  const A = this.generators[0].value;
                  const B = this.generators[1].value;
                  return (A ^ B) & playerPSB;
              },
              expr: '(A⊕B).C',
              isBoss: true,
              health: 12 + maxWaves
            }
            
        ];

        // ===== [ CONSTANTES DE CORES E CONFIGURAÇÕES VISUAIS ] ===== //
        const PLAYER_COLOR = 0x0077ff;          // Cor azul do jogador (hexadecimal)
        const ENEMY_COLOR = 0xff3300;           // Cor vermelha dos inimigos
        const PROJECTILE_COLOR = 0xffffff;      // Cor branca dos projéteis do jogador
        const ENEMY_PROJECTILE_COLOR = 0xff2200;// Cor vermelha dos projéteis inimigos
        const POWERUP_COLOR = 0x00ff00;         // Cor verde dos power-ups
        
        // ===== [ CONSTANTES DA AREA DO JOGO ] ===== //
        const PLAY_AREA = { x: 30, y: 20 };     // Dimensões da área jogável (unidades 3D)  o dobro do original = x: 16, y: 10

        // ===== [ VARIÁVEIS DE RENDERIZAÇÃO ] ===== //
        let renderer, scene, camera;            // Objetos principais do Three.js
        let width = window.innerWidth,          // Largura da janela
            height = window.innerHeight;        // Altura da janela

               
        // ===== [ ESTADO DO JOGO ] ===== //
        let gameState = GAME_STATE.START;       // Controla o estado atual (início/jogando/game over)

        
        // ===== [ VARIÁVEIS DO JOGADOR ] ===== //
        let player,                             // Objeto com posição/speed do jogador
            playerPSB = 1,                      // Valor lógico atual do jogador (0 ou 1)
            playerHealth = 5,                   // Vida atual
            playerMaxHealth = 5,                // Vida máxima
            playerScore = 0;                    // Pontuação
            window.playerPSB = playerPSB;       // cria uma referência global
        
        // ===== [ OBJETOS 3D DO JOGADOR ] ===== //
        let playerShip,                         // Malha 3D da nave
            playerThruster,                     // Efeito de propulsão
            playerPSBMesh,                      // Sprite do valor lógico (PSB)
            playerHealthBar;                    // Barra de vida flutuante
        
        // ===== [ ARRAYS DE ENTIDADES ] ===== //
        let enemies = [],                       // Lista de inimigos ativos
            projectiles = [],                   // Projéteis do jogador
            enemyProjectiles = [],              // Projéteis inimigos
            explosions = [],                    // Efeitos de explosão
            powerUps = [];                      // Power-ups coletáveis
        
        // ===== [ CONTROLES E OPERADORES ] ===== //
        let operatorIndex = 0;                  // Índice do operador lógico selecionado
        
        // ===== [ SISTEMA DE BOMBAS ] ===== //
        const INITIAL_BOMB_COUNT = 15;          // Quantidade inicial de bombas (não usado diretamente)
        let bombCounts = {};                    // Contagem de bombas por operador (ex: { AND: 10 })
        let bombReplenishedAtScore = {};        // Pontuações que já deram recarga de bombas
        
        // ===== [ INPUT ] ===== //
        let keys = {};                          // Rastreia teclas pressionadas ({ KeyA: true/false })
        
        // ===== [ ELEMENTOS VISUAIS ] ===== //
        let stars = [];                         // Partículas de estrelas de fundo
        let hud = {};                           // Elementos de UI (health, score, etc) criados dinamicamente            
          
        
        // ===== [ OVERLAYS DE TELA ] ===== //
        let pauseOverlay,                       // Tela de pausa
            startOverlay,                       // Tela inicial
            gameOverOverlay,                    // Tela de game over
            winOverlay;                         // Tela de vitória
        
        // ===== [ TIMERS ] ===== //
        let lastFire = 0,                       // Último momento que o jogador atirou
            fireDelay = 0.25;                   // Atraso entre tiros (segundos)
        let lastEnemyFire = 0,                  // Último tiro inimigo
            enemyFireDelay = 1.5;               // Atraso entre tiros inimigos
        let lastUpdate = performance.now();     // Timestamp da última atualização (para cálculo de deltaTime)
        

        // Inicializa os contadores de bombas
        function initBombCounts() {
            OPERATORS.forEach(op => {          
                bombCounts = {
                    'AND': 10,
                    'OR': 8,
                    'XOR': 12,
                    'NAND': 8,
                    'NOR': 15,
                    'XNOR': 15
                };
                bombReplenishedAtScore = {};                
            });
        }
        
        function createRenderer() {
            renderer = new THREE.WebGLRenderer({ antialias: true });   
            renderer.setSize(width, height);
            document.body.appendChild(renderer.domElement);            
        }

        function createCamera() {
            camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 100);
            //camera.position.set(0, 0, 22);  // x,y,z
            camera.position.set(0, 0, 25);  // x (movimento radial) ,y (movimento de elevação), z (movimento em inclinação)
            camera.lookAt(0, 0, 0); // Foco no centro da cena            
        }
        
        function createScene() {
            scene = new THREE.Scene();   // Cria a cena primeiro!
        
            // 1. Carrega a imagem de fundo (cobre toda a tela automaticamente)
            new THREE.TextureLoader().load(
                './figs/space_background_horizontal2.png',
                (texture) => {
                    scene.background = texture; // Fundo estático e fixo
                    console.log("Fundo carregado!");
                },
                undefined, // Barra de progresso (opcional)
                (error) => {
                    console.error("Erro no fundo:", error);
                    scene.background = new THREE.Color(0x0a0e2a); // Fallback se a imagem falhar
                }
            );
        
            // 2. Adicione as luzes (mantenha isso)
            let ambient = new THREE.AmbientLight(0xffffff, 0.7);
            let dir = new THREE.DirectionalLight(0xffffff, 0.8);
            dir.position.set(0, 0, 10);
            scene.add(ambient, dir);
        }

        
        function createPlayer() {
            // Primeiro, cria o objeto 'player' com as posições iniciais
            player = {
                x: 0,
                y: -PLAY_AREA.y / 2.2,
                speed: 7.5
            };
        
            // Depois, cria a nave e o PSB usando player.x e player.y
            let geo = new THREE.ConeGeometry(0.6, 1.6, 5);
            let mat = new THREE.MeshLambertMaterial({ color: PLAYER_COLOR });
            playerShip = new THREE.Mesh(geo, mat);
            playerShip.rotation.z = Math.PI;
            playerShip.position.set(player.x, player.y, 0); // Usa player.x e player.y
            scene.add(playerShip);
        
            // Thruster e health bar (mantido igual)
            let thrusterGeo = new THREE.CylinderGeometry(0.18, 0.01, 0.4, 8);
            let thrusterMat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.7 });
            playerThruster = new THREE.Mesh(thrusterGeo, thrusterMat);
            playerThruster.position.set(0, -0.95, 0);
            playerThruster.rotation.x = Math.PI / 2;
            playerShip.add(playerThruster);
        
            playerHealthBar = createBar(1.5, 0.12, 0x00ff55, 0.2);
            playerHealthBar.position.set(0, 1.2, 0);
            playerShip.add(playerHealthBar);
        
            // Agora o PSB pode usar player.x e player.y sem erro
            playerPSBMesh = createPSBMesh(playerPSB);
            playerPSBMesh.position.set(player.x, player.y + 1.7, 0); // Posição correta desde o início
            scene.add(playerPSBMesh);
        }

        
        function createPSBMesh(val) {
            let canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            let ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 128, 128);
            ctx.font = 'bold 88px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = val ? '#0090ff' : '#ff2222';
            ctx.shadowBlur = 12;
            ctx.fillStyle = val ? '#0090ff' : '#ff2222';
            ctx.fillText(val ? '1' : '0', 64, 64);
            let tex = new THREE.CanvasTexture(canvas);
            let mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
            let sprite = new THREE.Sprite(mat);
            sprite.scale.set(0.9, 0.9, 1);
            sprite.psbValue = val;
            return sprite;
        }

        function updatePSBMesh(val) {
            let sprite = playerPSBMesh;
            let canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            let ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 128, 128);
            ctx.font = 'bold 88px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = val ? '#0090ff' : '#ff2222';
            ctx.shadowBlur = 12;
            ctx.fillStyle = val ? '#0090ff' : '#ff2222';
            ctx.fillText(val ? '1' : '0', 64, 64);
            sprite.material.map.image = canvas;
            sprite.material.map.needsUpdate = true;
            sprite.psbValue = val;
        }

        function createBar(w, h, color, border) {
            let group = new THREE.Group();
            let bgGeo = new THREE.PlaneGeometry(w + border, h + border);
            let bgMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
            let bg = new THREE.Mesh(bgGeo, bgMat);
            group.add(bg);
            let fgGeo = new THREE.PlaneGeometry(w, h);
            let fgMat = new THREE.MeshBasicMaterial({ color: color });
            let fg = new THREE.Mesh(fgGeo, fgMat);
            fg.position.z = 0.01;
            fg.name = 'bar';
            group.add(fg);
            return group;
        }

        function setBarValue(bar, frac) {
            let fg = bar.children.find(m => m.name === 'bar');
            fg.scale.x = Math.max(0.01, frac);
            fg.position.x = -(1 - frac) * (fg.geometry.parameters.width / 2);
        }

        function getSafePSB() {
            return window.playerPSB ?? 1; // Garante sempre 0 ou 1
        }
        
        function spawnEnemy(type, x, y) {
            let mesh;
        
            // ==================== [1. DEFINE VIDA POR TIPO DE NAVE] ====================
            let health;
            if (type.shape === 'cube') {  // Caças
                health = 2 + Math.floor(wave * 0.5);  // Wave 1 = 2 → ajustado para mínimo 3 abaixo
            } else if (type.shape === 'tetra') {  // Cruzadores
                health = 3 + Math.floor(wave * 0.7);  // Wave 5 = 6
            } else if (type.shape === 'octahedron') {  // Destroyers
                health = 4 + Math.floor(wave * 1.0);  // Wave 7 = 11
            }
            health = Math.max(health, 3);  // Garante vida mínima = 3
        
            // ==================== [2. CRIA GEOMETRIA] ====================
            if (type.shape === 'cube') {
                mesh = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 1, 1),
                    new THREE.MeshLambertMaterial({ color: ENEMY_COLOR })
                );
            } else if (type.shape === 'tetra') {
                mesh = new THREE.Mesh(
                    new THREE.TetrahedronGeometry(0.7),
                    new THREE.MeshLambertMaterial({ color: ENEMY_COLOR })
                );
            } else if (type.shape === 'octahedron') {
                mesh = new THREE.Mesh(
                    new THREE.OctahedronGeometry(0.8),
                    new THREE.MeshLambertMaterial({ 
                        color: ENEMY_COLOR,
                        emissive: 0xff3300,
                        emissiveIntensity: 0.3
                    })
                );
            }
            mesh.position.set(x, y, 0);
        
            // ==================== [3. ESTRUTURA DE DANO/EXIBIÇÃO] ====================
            let healthBar = createBar(1.1, 0.11, 0xff4444, 0.18);
            healthBar.position.set(0, -0.8, 0);
            mesh.add(healthBar);
        
            let ab = type.ab;
            let A = ab ? (type.A ? type.A() : Math.round(Math.random())) : null;
            let B = ab ? (type.B ? type.B() : Math.round(Math.random())) : null;
            let ev = type.ev ? type.ev() : (A !== null && B !== null ? eval(type.expr.replace('.', '&').replace('+', '|').replace('⊕', '^')) : null);
            let evText = type.expr || ev?.toString();
        
            let evMesh = createEVSprite(evText, A, B, type.expr);
            evMesh.position.set(0, 1.2, 0);
            mesh.add(evMesh);
            scene.add(mesh);
        
            return {
                mesh, health, maxHealth: health, healthBar, ev, evMesh, ab, A, B, expr: type.expr, alive: true, type
            };
        }

        function updateDynamicEnemies(dt) {
            for (let e of enemies) {
                if (!e.alive || !e.type.isDynamic) continue;
                
                e.changeTimer = (e.changeTimer || 0) + dt;
                if (e.changeTimer >= e.type.changeInterval) {
                    e.changeTimer = 0;
                    
                    // Atualiza A e B (se existirem)
                    if (e.type.A) e.A = e.type.A();
                    if (e.type.B) e.B = e.type.B(playerPSB); // Passa playerPSB para níveis como o 6
                    
                    // Recalcula ev (usando a expressão ou função ev)
                    e.ev = e.type.ev ? e.type.ev() : 
                          (e.A !== null && e.B !== null ? eval(e.expr.replace('.', '&').replace('+', '|').replace('⊕', '^')) : null);
                    
                    // Atualiza o sprite da expressão
                    updateEnemyEVSprite(e);
                }
            }
        }

        function updateEnemyEVSprite(enemy) {
            // Remove o sprite antigo
            enemy.mesh.remove(enemy.evMesh);
            
            // Cria um novo sprite com os valores atualizados
            let evText = enemy.expr || enemy.ev?.toString();
            enemy.evMesh = createEVSprite(evText, enemy.A, enemy.B, enemy.expr);
            enemy.evMesh.position.set(0, 0.8, 0);
            enemy.mesh.add(enemy.evMesh);
        }
        
        function spawnMothership() {
            const type = ENEMY_TYPES.find(t => t.isBoss);
            const mothership = spawnEnemy(type, 0, PLAY_AREA.y/2.5);                        
            mothership.mesh.scale.set(1.5, 1.5, 1.5);  // Expansão
            
            // Adiciona geradores
            mothership.generators = [ // Preenche os geradores aqui
                { label: 'A', value: Math.round(Math.random()) },
                { label: 'B', value: Math.round(Math.random()) }
            ];
            
            return mothership;
        }
                
        function updateMothership(dt) {
            if (!mothership || !mothership.alive) return;
        
            // Atualiza geradores A/B a cada 5 segundos
            mothership.changeTimer = (mothership.changeTimer || 0) + dt;
            if (mothership.changeTimer >= 5) {
                mothership.changeTimer = 0;
                mothership.generators[0].value = Math.round(Math.random()); // A
                mothership.generators[1].value = Math.round(Math.random()); // B
                mothership.ev = mothership.type.ev(); // Recalcula (A⊕B).C
                updateEnemyEVSprite(mothership); // Atualiza HUD
            }
        }
        
        function createEVSprite(text, A, B, expr) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 164;
            const ctx = canvas.getContext('2d');
        
            // Expressão (amarelo)
            ctx.font = 'bold 70px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = "#ffff55";
            ctx.shadowColor = '#000';
            ctx.shadowBlur = 8;
            ctx.fillText(text, 128, 40);      // 
        
            // Fundo das variáveis (se existirem)
            if (A !== null && B !== null && expr) {
                ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                ctx.fillRect(50, 90, 156, 40);
                
                // Variáveis (verde)
                ctx.font = 'bold 55px Arial';
                ctx.fillStyle = "#55ff55";
                ctx.shadowBlur = 0;
                ctx.fillText(`A = ${A}  B = ${B}`, 128, 100);
            }
        
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(3.2, 2.0, 1);
            return sprite;
        }
        
        function spawnProjectile(x, y, dx, dy, operator) {            
            playSound('shoot');             
            let geo = new THREE.CylinderGeometry(0.15, 0.15, 0.7, 10);
            let mat = new THREE.MeshBasicMaterial({ color: PROJECTILE_COLOR, emissive: PROJECTILE_COLOR });            
            let mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = Math.PI / 2;
            mesh.position.set(x, y + 0.8, 0.05);
            scene.add(mesh);
            projectiles.push({ mesh, dx, dy, operator, alive: true });
        }

        function spawnEnemyProjectile(x, y, dx, dy) {
            // Cria a geometria de um cilindro para o projétil:
            // - Raio superior/inferior: 0.14 (tamanho da base)
            // - Altura: 0.5 (comprimento do projétil)
            // - Segmentos: 8 (suavidade do cilindro)
            let geo = new THREE.CylinderGeometry(0.14, 0.14, 0.5, 8);
        
            // Define o material do projétil:
            // - Cor: ENEMY_PROJECTILE_COLOR (vermelho, definido nas constantes)
            // - Não emite luz (MeshBasicMaterial)
            let mat = new THREE.MeshBasicMaterial({ color: ENEMY_PROJECTILE_COLOR });
        
            // Combina geometria + material em um objeto 3D (malha)
            let mesh = new THREE.Mesh(geo, mat);
        
            // Rotaciona o projétil 90 graus no eixo X (para ficar "deitado")
            mesh.rotation.x = Math.PI / 2; // π/2 radianos = 90°
        
            // Posiciona o projétil:
            // - x, y: Posição da nave inimiga (passada como parâmetro)
            // - y - 1.0: Ajuste para sair abaixo da nave
            // - z: 0.05 (ligeiramente à frente para evitar sobreposição visual)
            mesh.position.set(x, y - 1.0, 0.05);
        
            // Adiciona o projétil à cena principal
            scene.add(mesh);
        
            // Armazena o projétil no array global `enemyProjectiles`:
            enemyProjectiles.push({
                mesh,      // Objeto 3D
                dx, dy,    // Direção (normalizada e multiplicada pela velocidade)
                alive: true // Flag para controle
            });
        }
        
        function spawnExplosion(x, y) {
            playSound('explosion');
            let group = [];
            for (let i = 0; i < 15; i++) {
                let geo = new THREE.SphereGeometry(0.13 + Math.random() * 0.09, 6, 6);
                let mat = new THREE.MeshBasicMaterial({ color: Math.random() < 0.5 ? 0xff3300 : 0xff9900 });
                let mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y, 0.1);
                mesh.dx = (Math.random() - 0.5) * 2.2;
                mesh.dy = (Math.random() - 0.5) * 2.2;
                mesh.ttl = 0.45 + Math.random() * 0.2;
                scene.add(mesh);
                group.push(mesh);
            }
            explosions.push({ group, time: 0 });
            
            // 30% chance de dropar power-up
            if (Math.random() < 0.3) {
                spawnPowerUp(x, y);
            }
        }
                
        function spawnPowerUp(x, y) {
            // Toca o som de power-up aparecendo (usando o sistema de áudio definido anteriormente)
            playSound('powerup');
        
            // Cria a geometria de uma esfera para o power-up:
            // - Raio: 0.3 unidades
            // - Segmentos horizontais/verticais: 16 (suavidade da esfera)
            let geo = new THREE.SphereGeometry(0.3, 16, 16);
        
            // Define o material do power-up:
            // - Cor base: POWERUP_COLOR (verde, definido nas constantes)
            // - Emissivo: mesma cor (faz o power-up "brilhar" levemente)
            let mat = new THREE.MeshBasicMaterial({ 
                color: POWERUP_COLOR, 
                emissive: POWERUP_COLOR 
            });
        
            // Cria a malha 3D combinando geometria + material
            let mesh = new THREE.Mesh(geo, mat);
        
            // Posiciona o power-up nas coordenadas (x, y) recebidas como parâmetro,
            // com um pequeno offset no eixo Z (0.1) para evitar conflito de renderização
            mesh.position.set(x, y, 0.1);
        
            // Adiciona o power-up à cena principal
            scene.add(mesh);
        
            // Armazena o power-up no array global `powerUps` com suas propriedades:
            powerUps.push({
                mesh,        // Referência ao objeto 3D
                alive: true, // Flag para controle (se ainda está ativo)
                ttl: 9.0,   // Time-To-Live (tempo de vida em segundos)
                dy: -2       // Velocidade vertical (movimento para baixo)
            });
        }

        
        function resetGame() {
            
            // Remove todos os objetos 3D da cena (limpeza total)
            while (scene.children.length) scene.remove(scene.children[0]);
        
            // Reseta arrays de entidades do jogo
            stars = [];            // Partículas de fundo
            enemies = [];          // Inimigos ativos
            projectiles = [];      // Projéteis do jogador
            enemyProjectiles = []; // Projéteis inimigos
            explosions = [];       // Efeitos de explosão
            powerUps = [];         // Power-ups coletáveis
            mothership = null;     // Remove referência à nave-mãe
        
            // Recria elementos essenciais
           // createStars();       // Gera novas estrelas de fundo
            createPlayer();      // Recria a nave do jogador        
            
            // Reseta status do jogador
            playerHealth = playerMaxHealth;  // Vida máxima
            playerScore = 0;                 // Pontuação zerada
            wave = 1;                        // Volta para a fase 1
            operatorIndex = 0;               // Operador lógico padrão (AND)
            playerPSB = 1;                   // Valor lógico inicial (1)
            updatePSBMesh(playerPSB);        // Atualiza visualização do PSB
        
            // Reseta timers de disparo
            lastFire = 0;        // Tempo do último tiro do jogador
            lastEnemyFire = 0;   // Tempo do último tiro inimigo
            waveEnemies = 0;     // Contador de inimigos na wave
        
            // Reinicia sistema de bombas
            initBombCounts();            // Recarrega contagem de bombas
            bombReplenishedAtScore = {}; // Limpa registro de recargas
                    
        }

        function getEnemyType(wave, index) {
            
            // Waves 1-3: Níveis 1-3 puros
            if (wave === 1) return ENEMY_TYPES[0]; // Caças (nível 1)
            if (wave === 2) return ENEMY_TYPES[1]; // Caças dinâmicos (nível 2)
            if (wave === 3) return ENEMY_TYPES[2]; // Caças PSB (nível 3)
        
            // Wave 4: Mistura de níveis 1-3 (4:2:3)
            if (wave === 4) {
                const types = [0, 0, 0, 0, 1, 1, 2, 2, 2]; // Proporção 4:2:3
                return ENEMY_TYPES[types[index % types.length]];
            }
        
            // Wave 5: Cruzadores básicos (nível 4)
            if (wave === 5) return ENEMY_TYPES[3 + (index % 3)]; // AND, OR, XOR
        
            // Wave 6: Cruzadores dinâmicos (nível 5)
            if (wave === 6) return ENEMY_TYPES[6 + (index % 3)]; // AND, OR, XOR dinâmicos
        
            // Wave 7: Cruzadores A fixo + B = PSB (nível 6)
            if (wave === 7) return ENEMY_TYPES[9 + (index % 3)]; // AND, OR, XOR com B dinâmico
        
            // Wave 8: Mistura de níveis 1, 5, 7 (4:4:4)
            if (wave === 8) {
                const types = [0, 6, 9, 0, 7, 10, 0, 6, 9, 0, 7, 10]; // Proporção 4:4:4
                return ENEMY_TYPES[types[index % types.length]];
            }
        
            // Wave 9: Mistura de níveis 2, 3, 6, 8 (3:3:4:3)
            if (wave === 9) {
                const types = [1, 2, 9, 1, 2, 12, 1, 2, 9, 1, 2, 12, 9, 12]; // Proporção 3:3:4:3
                return ENEMY_TYPES[types[index % types.length]];
            }
        
            // Wave 10: Nave-mãe + escoltas (será implementada separadamente)
            return ENEMY_TYPES[0]; // Padrão (não deve ocorrer)
        }
        
        function startWave(n) {
            
            // Wave 10: Nave-mãe + escoltas
            if (n === 10) {
                spawnMothership(); // Implemente essa função separadamente
                waveEnemies = 1; // Conta apenas a nave-mãe (escoltas são extras)
                return;
            }
        
            // Waves 1-9: Inimigos normais
            let nEnemies;
            if (n === 3) {
                nEnemies = 5; // Wave 3 tem 5 inimigos
            } else if (n >= 8) {
                nEnemies = 10; // Waves 8-9 têm mais inimigos
            } else {
                nEnemies = Math.min(4 + n, 7); // Waves 1-2,4-7: 4 a 7 inimigos
            }
            
            waveEnemies = nEnemies;
        
            for (let i = 0; i < nEnemies; i++) {
                let type = getEnemyType(n, i);
                let x = -PLAY_AREA.x / 2 + 1.5 + (i % nEnemies) * (PLAY_AREA.x - 3) / (nEnemies - 1);
                let y = PLAY_AREA.y / 2 - 1.5 - Math.random() * 1.4;
                enemies.push(spawnEnemy(type, x, y));
            }
        }


        function updateHUD() {
            // =============================================
            // ELEMENTO DE VIDA (COM ALERTA CONTÍNUO)
            // =============================================
            if (!hud.health) {
                hud.health = document.createElement('div');
                hud.health.style.position = 'fixed';
                hud.health.style.left = '18px';
                hud.health.style.top = '12px';
                hud.health.style.color = '#00ff88';
                hud.health.style.font = 'bold 22px monospace';
                hud.health.style.textShadow = '0 0 5px #003';
                document.body.appendChild(hud.health);
            }
            
            const isLowHealth = playerHealth <= playerMaxHealth * 0.2;
            
            // Efeitos de vida baixa (agora contínuos)
            if (isLowHealth && gameState === GAME_STATE.PLAYING && gameState !== GAME_STATE.PAUSED) {
                // Efeito sonoro: toca repetidamente ....
                if (!hud.lowHealthSoundInterval) {
                    playSound('lowHealth'); // Toca imediatamente
                    hud.lowHealthSoundInterval = setInterval(() => {
                        if (gameState === GAME_STATE.PLAYING && !pauseOverlay)  {  // ← Verificação extra
                            playSound('lowHealth');
                        }
                    }, 1000); // ... a cada 1000 milisegundos.
                }
                
                // Efeito visual piscante
                hud.health.style.color = (Math.floor(Date.now() / 200) % 2 === 0 
                    ? '#ff0000' 
                    : '#00ff88');
                hud.health.style.textShadow = '0 0 10px #ff0000';
            } else {
                // Remove alertas quando vida > 20% ou jogo não está em PLAYING
                if (hud.lowHealthSoundInterval) {
                    clearInterval(hud.lowHealthSoundInterval);
                    hud.lowHealthSoundInterval = null;
                    sounds.lowHealth.pause();  // ← Pausa o som imediatamente
                    sounds.lowHealth.currentTime = 0;  // ← Reinicia o áudio
                }
                hud.health.style.color = '#00ff88';
                hud.health.style.textShadow = '0 0 5px #003';
            }
            
            hud.health.innerHTML = 'Vida: ' + playerHealth;
        
            // =============================================
            // ELEMENTO DE PONTUAÇÃO 
            // =============================================
            if (!hud.score) {
                hud.score = document.createElement('div');
                hud.score.style.position = 'fixed';
                hud.score.style.right = '18px';
                hud.score.style.top = '12px';
                hud.score.style.color = '#fff';
                hud.score.style.font = 'bold 22px monospace';
                hud.score.style.textShadow = '0 0 5px #003';
                document.body.appendChild(hud.score);
            }
            hud.score.innerHTML = 'Pontuação: ' + playerScore;
        
            // =============================================
            // ELEMENTO PSB 
            // =============================================
            if (!hud.psb) {
                hud.psb = document.createElement('div');
                hud.psb.style.position = 'fixed';
                hud.psb.style.left = '18px';
                hud.psb.style.bottom = '18px';
                hud.psb.style.color = '#fff';
                hud.psb.style.font = 'bold 32px monospace';
                hud.psb.style.textShadow = '0 0 8px #0077ff';
                document.body.appendChild(hud.psb);
            }
            hud.psb.innerHTML = 'PSB: <span style="color:' + (playerPSB ? '#0090ff' : '#ff2222') + '">' + playerPSB + '</span>';
        
            // =============================================
            // ELEMENTO DE OPERADOR
            // =============================================
            if (!hud.op) {
                hud.op = document.createElement('div');
                hud.op.style.position = 'fixed';
                hud.op.style.bottom = '18px';
                hud.op.style.left = '50%';
                hud.op.style.transform = 'translateX(-50%)';
                hud.op.style.color = '#fff';
                hud.op.style.font = 'bold 28px monospace';
                hud.op.style.textShadow = '0 0 8px #fff';
                document.body.appendChild(hud.op);
            }
            const currentOperatorKey = OPERATORS[operatorIndex].key;          
            hud.op.innerHTML = 'Operador: <span style="color:#fff;background:#222;padding:2px 10px;border-radius:7px;">' + 
                   OPERATORS[operatorIndex].key + '</span>' +
                   ' <span style="color:#00ff88;font-size:22px;">(' + bombCounts[OPERATORS[operatorIndex].key] + ')</span>';
        
            // =============================================
            // ELEMENTO DE Fases (WAVE)
            // =============================================
            if (!hud.wave) {
                hud.wave = document.createElement('div');
                hud.wave.style.position = 'fixed';
                hud.wave.style.top = '12px';
                hud.wave.style.left = '50%';
                hud.wave.style.transform = 'translateX(-50%)';
                hud.wave.style.color = '#fff';
                hud.wave.style.font = 'bold 22px monospace';
                hud.wave.style.textShadow = '0 0 7px #0077ff';
                document.body.appendChild(hud.wave);
            }
            if (gameState === GAME_STATE.PLAYING && !mothership)
                hud.wave.innerHTML = 'Fase ' + wave + ' de ' + maxWaves;
            else if (mothership && gameState === GAME_STATE.PLAYING)
                hud.wave.innerHTML = 'Nave-Mãe';
            else
                hud.wave.innerHTML = '';
        
            // =============================================
            // GERADORES DA NAVE-MÃE 
            // =============================================
            if (mothership && mothership.alive) {
                if (!hud.bossGens) {
                    hud.bossGens = document.createElement('div');
                    hud.bossGens.style.position = 'fixed';
                    hud.bossGens.style.top = '50px';
                    hud.bossGens.style.left = '50%';
                    hud.bossGens.style.transform = 'translateX(-50%)';
                    hud.bossGens.style.color = '#ff5555';
                    hud.bossGens.style.font = 'bold 18px monospace';
                    hud.bossGens.style.textShadow = '0 0 5px #000';
                    document.body.appendChild(hud.bossGens);
                }
                hud.bossGens.innerHTML = `Geradores: A=${mothership.generators[0].value} | B=${mothership.generators[1].value}`;
            } else if (hud.bossGens) {
                hud.bossGens.innerHTML = '';
            }
        }
       
        function clearHUD() {
            for (let k in hud) {
                if (hud[k] && hud[k].parentNode) hud[k].parentNode.removeChild(hud[k]);
                hud[k] = null;
            }
        }

        function showOverlay(type, text, subtext) {
            let overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.left = '0';
            overlay.style.top = '0';
            overlay.style.width = '100vw';
            overlay.style.height = '100vh';            
            overlay.style.background = `rgba(10,14,42,0.8)`; // Usa o parâmetro de opacidade? 80%
            overlay.style.display = 'flex';
            overlay.style.flexDirection = 'column';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '1000';
            overlay.style.fontFamily = 'monospace';
            let title = document.createElement('div');
            title.style.fontSize = '58px';
            title.style.color = '#fff';
            title.style.textShadow = '0 0 24px #0077ff, 0 0 12px #fff';
            title.style.fontWeight = 'bold';
            title.style.letterSpacing = '2px';
            title.innerHTML = text;
            overlay.appendChild(title);
            if (subtext) {
                let st = document.createElement('div');
                st.style.fontSize = '28px';
                st.style.color = '#fff';
                st.style.marginTop = '28px';
                st.style.textShadow = '0 0 8px #0077ff';
                st.innerHTML = subtext;
                overlay.appendChild(st);
            }
            document.body.appendChild(overlay);
            return overlay;
        }

        function removeOverlay(overlay) {
            if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
        }

        function keyDown(e) {
            if (e.repeat) return;
            keys[e.code] = true;
        
            // Tecla C - Alternar PSB (NOT) - Funciona em qualquer estado
            if (e.code === 'KeyC') {
                playerPSB = 1 - playerPSB;
                window.playerPSB = playerPSB;
                updatePSBMesh(playerPSB);
                return;
            }
        
            switch (gameState) {
                case GAME_STATE.START:
                    if (e.code === 'Space') {
                        removeOverlay(startOverlay);
                        resetGame();
                        gameState = GAME_STATE.PLAYING;
                        startWave(wave);
                    }
                    break;
        
                case GAME_STATE.GAME_OVER:
                    if (e.code === 'KeyR') {
                        removeOverlay(gameOverOverlay);
                        clearHUD();
                        resetGame();
                        gameState = GAME_STATE.PLAYING;
                        startWave(wave);
                    }
                    break;
        
                case GAME_STATE.WIN:
                    if (e.code === 'KeyR') {
                        removeOverlay(winOverlay);
                        clearHUD();
                        resetGame();
                        gameState = GAME_STATE.PLAYING;
                        startWave(wave);
                    }
                    break;
        
                case GAME_STATE.PLAYING:
                    if (e.code === 'KeyP') {
                        // Cria overlay de pause com transparência
                        pauseOverlay = document.createElement('div');
                        pauseOverlay.style.position = 'fixed';
                        pauseOverlay.style.left = '0';
                        pauseOverlay.style.top = '0';
                        pauseOverlay.style.width = '100vw';
                        pauseOverlay.style.height = '100vh';
                        pauseOverlay.style.background = 'rgba(10,14,42,0.4)'; // 40% de opacidade, último parâmetro.
                        pauseOverlay.style.display = 'flex';
                        pauseOverlay.style.flexDirection = 'column';
                        pauseOverlay.style.alignItems = 'center';
                        pauseOverlay.style.justifyContent = 'center';
                        pauseOverlay.style.zIndex = '1000';
                        pauseOverlay.style.fontFamily = 'monospace';
                        
                        let title = document.createElement('div');
                        title.style.fontSize = '58px';
                        title.style.color = '#fff';
                        title.style.textShadow = '0 0 24px #0077ff, 0 0 12px #fff';
                        title.style.fontWeight = 'bold';
                        title.style.letterSpacing = '2px';
                        title.innerHTML = 'Jogo Pausado';
                        pauseOverlay.appendChild(title);
                        
                        let subtext = document.createElement('div');
                        subtext.style.fontSize = '28px';
                        subtext.style.color = '#fff';
                        subtext.style.marginTop = '28px';
                        subtext.style.textShadow = '0 0 8px #0077ff';
                        subtext.innerHTML = '<span style="font-size:22px;">Tecle P para continuar</span>';
                        pauseOverlay.appendChild(subtext);
                        
                        document.body.appendChild(pauseOverlay);
                        gameState = GAME_STATE.PAUSED;
                    }
        
                    if (e.code === 'Tab') {
                        operatorIndex = (operatorIndex + 1) % OPERATORS.length;
                        e.preventDefault();
                    }
        
                    if (e.code === 'Space') {
                        let now = performance.now() / 1000;
                        const currentOperatorKey = OPERATORS[operatorIndex].key;
                        if (bombCounts[currentOperatorKey] > 0 && now - lastFire > fireDelay) {
                            fireProjectile();
                            bombCounts[currentOperatorKey]--;
                            lastFire = now;
                        }
                    }
                    break;
        
                case GAME_STATE.PAUSED:
                    if (e.code === 'KeyP') {
                        removeOverlay(pauseOverlay);
                        pauseOverlay = null;
                        gameState = GAME_STATE.PLAYING;                        
                    }
                    break;
            }
        }
        
        
        function keyUp(e) {
            keys[e.code] = false;
        }

        function fireProjectile() {
            
            // Inicializa variáveis para encontrar o alvo mais próximo:
            // - `target`: armazenará o inimigo mais próximo
            // - `minDist`: distância mínima inicializada com um valor alto (1000)
            let target = null, minDist = 1000;
        
            // Percorre todos os inimigos ativos no array `enemies`
            for (let e of enemies) {
                // Ignora inimigos mortos
                if (!e.alive) continue;
        
                // Calcula a distância entre o jogador e o inimigo atual (e)
                // Usa diferença de coordenadas (dx e dy) e distância quadrática (d = dx² + dy²)
                // (Distância quadrática é mais eficiente que Math.sqrt)
                let dx = e.mesh.position.x - player.x;
                let dy = e.mesh.position.y - player.y;
                let d = dx * dx + dy * dy;
        
                // Se o inimigo atual estiver mais próximo que o registrado:
                if (d < minDist) {
                    minDist = d;       // Atualiza a distância mínima
                    target = e;        // Define este inimigo como alvo atual
                }
            }
        
            // Verifica se a nave-mãe existe e está viva
            if (mothership && mothership.alive) {
                // Calcula a distância entre jogador e nave-mãe
                let dx = mothership.mesh.position.x - player.x;
                let dy = mothership.mesh.position.y - player.y;
                let d = dx * dx + dy * dy;
        
                // Se a nave-mãe estiver mais próxima que outros inimigos:
                if (d < minDist) {
                    minDist = d;
                    target = mothership; // Prioriza a nave-mãe como alvo
                }
            }
        
            // Se nenhum alvo foi encontrado, encerra a função
            if (!target) return;
        
            // Calcula o vetor direção do jogador para o alvo (target)
            let dx = target.mesh.position.x - player.x;
            let dy = target.mesh.position.y - player.y;
        
            // Calcula a magnitude (distância real) usando Math.sqrt
            let mag = Math.sqrt(dx * dx + dy * dy);
        
            // Evita divisão por zero (caso raro de distância = 0)
            if (mag === 0) mag = 1;
        
            // Normaliza o vetor (transforma em vetor unitário: comprimento = 1)
            dx /= mag;
            dy /= mag;
        
            // Dispara o projétil:
            // - Posição: (player.x, player.y)
            // - Direção: (dx * 13, dy * 13) (13 = velocidade do projétil)
            // - operatorIndex: tipo de operador lógico selecionado
            spawnProjectile(player.x, player.y, dx * 13, dy * 13, operatorIndex);
        }

        
        function enemyFireLogic(dt) {
            // Obtém o tempo atual em segundos (para cálculos de intervalo de disparo)
            let now = performance.now() / 1000;
        
            // Verifica se o tempo desde o último disparo inimigo é maior que o intervalo permitido
            if (now - lastEnemyFire > enemyFireDelay) {
        
                // Itera sobre todos os inimigos ativos
                for (let e of enemies) {
                    // Pula inimigos mortos
                    if (!e.alive) continue;
        
                    // Calcula a direção do jogador em relação ao inimigo (vetor X e Y)
                    let dx = player.x - e.mesh.position.x;
                    let dy = player.y - e.mesh.position.y;
        
                    // Calcula a magnitude (distância) entre inimigo e jogador
                    let mag = Math.sqrt(dx * dx + dy * dy);
        
                    // Evita divisão por zero (caso raro de distância zero)
                    if (mag === 0) mag = 1;
        
                    // Normaliza o vetor de direção (transforma em vetor unitário)
                    dx /= mag;
                    dy /= mag;
        
                    // 70% de chance de disparar (Math.random() < 0.7)
                    if (Math.random() < 0.7)
                        // Cria um projétil na posição do inimigo, com direção ao jogador e velocidade 8
                        spawnEnemyProjectile(e.mesh.position.x, e.mesh.position.y, dx * 8, dy * 8);
                }
        
                // Lógica similar para a nave-mãe (se existir e estiver viva)
                if (mothership && mothership.alive && Math.random() < 0.8) {
                    let dx = player.x - mothership.mesh.position.x;
                    let dy = player.y - mothership.mesh.position.y;
                    let mag = Math.sqrt(dx * dx + dy * dy);
                    if (mag === 0) mag = 1;
                    dx /= mag;
                    dy /= mag;
        
                    // Dispara com velocidade 9 (ligeiramente mais rápido que inimigos normais)
                    // O -0.6 no Y posiciona o tiro abaixo da nave-mãe
                    spawnEnemyProjectile(mothership.mesh.position.x, mothership.mesh.position.y - 0.6, dx * 9, dy * 9);
                }
        
                // Atualiza o tempo do último disparo
                lastEnemyFire = now;
            }
        }
        

        function updateProjectiles(dt) {
            for (let p of projectiles) {
                if (!p.alive) continue;
                p.mesh.position.x += p.dx * dt;
                p.mesh.position.y += p.dy * dt;
                if (Math.abs(p.mesh.position.x) > PLAY_AREA.x / 2 + 2 || Math.abs(p.mesh.position.y) > PLAY_AREA.y / 2 + 2) {
                    scene.remove(p.mesh);
                    p.alive = false;
                    continue;
                }
                for (let e of enemies) {
                    if (!e.alive) continue;
                    let ex = e.mesh.position.x, ey = e.mesh.position.y;
                    let px = p.mesh.position.x, py = p.mesh.position.y;
                    let dist = Math.sqrt((ex - px) ** 2 + (ey - py) ** 2);
                    if (dist < 0.8) {
                        let op = OPERATORS[p.operator];
                        let psb = playerPSB;
                        let ev = e.ev;
                        if (e.expr) {
                            if (e.expr === 'A&B') ev = e.A & e.B;
                            if (e.expr === 'A|B') ev = e.A | e.B;
                            if (e.expr === 'A^B') ev = e.A ^ B;
                        }
                        let result = op.fn(psb, ev);
                        if (result === 1) {
                            e.health--;
                            setBarValue(e.healthBar, e.health / e.maxHealth);
                            if (e.health <= 0) {
                                e.alive = false;
                                scene.remove(e.mesh);
                                spawnExplosion(ex, ey);
                                playerScore += 100;
                                waveEnemies--;
                            }
                        }
                        scene.remove(p.mesh);
                        p.alive = false;
                        break;
                    }
                }
                if (mothership && mothership.alive) {  
                    let ex = mothership.mesh.position.x, ey = mothership.mesh.position.y;  
                    let px = p.mesh.position.x, py = p.mesh.position.y;  
                    let dist = Math.sqrt((ex - px) ** 2 + (ey - py) ** 2);  
                    
                    if (dist < 1.5) {  
                        let op = OPERATORS[p.operator];  
                        let A = mothership.generators[0].value;  
                        let B = mothership.generators[1].value;  
                        let C = playerPSB;  
                        let expected = (A ^ B) & C; // (A⊕B).C  
                        let result = op.fn(C, (A ^ B)); // Aplica operador do jogador  
                        
                        if (result === expected && result === 1) {  
                            mothership.health--;  
                            setBarValue(mothership.healthBar, mothership.health / mothership.maxHealth);  
                            if (mothership.health <= 0) {  
                                mothership.alive = false;  
                                scene.remove(mothership.mesh);  
                                spawnExplosion(ex, ey);  
                                playerScore += 1000; // Pontuação maior para a nave-mãe  
                            }  
                        }  
                        scene.remove(p.mesh);  
                        p.alive = false;  
                    }  
                }  
                
            }
            projectiles = projectiles.filter(p => p.alive);
        }

        
        function updateEnemyProjectiles(dt) {
            // Itera sobre todos os projéteis inimigos ativos
            for (let p of enemyProjectiles) {
                if (!p.alive) continue; // Ignora projéteis marcados como inativos
        
                // Atualiza posição do projétil com base na velocidade (dx, dy) e delta time
                p.mesh.position.x += p.dx * dt;
                p.mesh.position.y += p.dy * dt;
        
                // Verifica se o projétil saiu dos limites da área de jogo
                if (Math.abs(p.mesh.position.x) > PLAY_AREA.x / 2 + 2 || 
                    Math.abs(p.mesh.position.y) > PLAY_AREA.y / 2 + 2) {
                    scene.remove(p.mesh); // Remove visualmente
                    p.alive = false;      // Marca como inativo
                    continue;
                }
        
                // Calcula distância entre o projétil e o jogador
                let px = p.mesh.position.x, py = p.mesh.position.y;
                let dist = Math.sqrt((player.x - px) ** 2 + (player.y - py) ** 2);
        
                // Verifica colisão com o jogador (raio de 0.7 unidades)
                if (dist < 0.7) {
                    // Remove o projétil da cena
                    scene.remove(p.mesh);
                    p.alive = false;
        
                    // Aplica dano ao jogador
                    playerHealth--;
                    setBarValue(playerHealthBar, playerHealth / playerMaxHealth); // Atualiza HUD
                    playSound('playerHit'); // Toca som de impacto
        
                    // Verifica morte do jogador
                    if (playerHealth <= 0) {
                        
                        // Ativa estado de Game Over
                        gameState = GAME_STATE.GAME_OVER;
                        playSound('gameOver'); // Toca som de derrota
                        
                        // Exibe overlay de Game Over
                        gameOverOverlay = showOverlay(
                            'gameover', 
                            'GAME OVER', 
                            'Pontuação: ' + playerScore + '<br><br>Tecle R para reiniciar'
                        );
                    }
                }
            }
        
            // Filtra apenas projéteis ativos (remove os marcados como !alive)
            enemyProjectiles = enemyProjectiles.filter(p => p.alive);
        }

        
        function updateExplosions(dt) {
            for (let e of explosions) {
                for (let m of e.group) {
                    m.position.x += m.dx * dt;
                    m.position.y += m.dy * dt;
                    m.ttl -= dt;
                    if (m.ttl < 0) {
                        scene.remove(m);
                    }
                }
            }
            explosions = explosions.filter(e => e.group.some(m => m.ttl > 0));
        }

        function updatePowerUps(dt) {
            for (let pu of powerUps) {
                if (!pu.alive) continue;
                
                // Movimento do power-up (velocidade constante, independente do tamanho da área)
                pu.mesh.position.y += pu.dy * dt;
                pu.ttl -= dt;
        
                // Condição de destruição: 
                // 1. Tempo esgotado -OU- 
                // 2. Saiu da área visível (baseado em PLAY_AREA.y atual)
                const isBelowScreen = pu.mesh.position.y < -PLAY_AREA.y * 0.8; // Ajuste para controlar quando desaparece. Quanto maior, 
                                                                               // mais próximo do final da tela.
                if (pu.ttl < 0 || isBelowScreen) {
                    scene.remove(pu.mesh);
                    pu.alive = false;
                    continue;
                }
        
                // Colisão com o jogador
                let dist = Math.sqrt((player.x - pu.mesh.position.x) ** 2 + (player.y - pu.mesh.position.y) ** 2);
                if (dist < 1.0) {
                    playSound('powerupCollect');
                    for (let key in bombCounts) {
                        if (key === 'OR' || key === 'NAND') {
                            bombCounts[key] = Math.min(bombCounts[key] + 3, 20);
                        } else if (key === 'NOR') {
                            bombCounts[key] = Math.min(bombCounts[key] + 5, 20);
                        } else {
                            bombCounts[key] = Math.min(bombCounts[key] + 4, 20);
                        }
                    }
                    scene.remove(pu.mesh);
                    pu.alive = false;
                    
                    // Efeito visual
                    let particles = [];
                    for (let i = 0; i < 20; i++) {
                        let geo = new THREE.SphereGeometry(0.1, 6, 6);
                        let mat = new THREE.MeshBasicMaterial({ color: POWERUP_COLOR });
                        let mesh = new THREE.Mesh(geo, mat);
                        mesh.position.set(pu.mesh.position.x, pu.mesh.position.y, 0.1);
                        mesh.dx = (Math.random() - 0.5) * 3;
                        mesh.dy = (Math.random() - 0.5) * 3;
                        mesh.ttl = 0.8 + Math.random() * 0.4;
                        scene.add(mesh);
                        particles.push(mesh);
                    }
                    explosions.push({ group: particles, time: 0 });
                }
            }
            powerUps = powerUps.filter(pu => pu.alive);
        }
        
        function checkScoreForBombReplenish() {
            const scoreThresholds = [500, 1500, 3000, 5000, 8000];
            for (const threshold of scoreThresholds) {
                if (playerScore >= threshold && !bombReplenishedAtScore[threshold]) {
                    for (let key in bombCounts) {
                        bombCounts[key] = Math.min(bombCounts[key] + 10, INITIAL_BOMB_COUNT * 2);
                    }
                    bombReplenishedAtScore[threshold] = true;
                    break;
                }
            }
        }

        function updatePlayer(dt) {
            let moveX = 0, moveY = 0;
            if (keys['KeyA'] || keys['ArrowLeft']) moveX -= 1;
            if (keys['KeyD'] || keys['ArrowRight']) moveX += 1;
            if (keys['KeyW'] || keys['ArrowUp']) moveY += 1;
            if (keys['KeyS'] || keys['ArrowDown']) moveY -= 1;
            let mag = Math.sqrt(moveX * moveX + moveY * moveY);
            if (mag > 0) {
                moveX /= mag; moveY /= mag;
                player.x += moveX * player.speed * dt;
                player.y += moveY * player.speed * dt;
                player.x = Math.max(-PLAY_AREA.x / 2 + 0.8, Math.min(PLAY_AREA.x / 2 - 0.8, player.x));
                player.y = Math.max(-PLAY_AREA.y / 2 + 0.7, Math.min(PLAY_AREA.y / 2 - 0.7, player.y));
                playerShip.position.set(player.x, player.y, 0);
                playerPSBMesh.position.set(player.x, player.y + 1.7, 0);
            }
            playerThruster.material.opacity = 0.7 + 0.2 * Math.abs(Math.sin(performance.now() / 110));
        }

        function gameLoop() {
            
            // Obtém o tempo atual em milissegundos
            let now = performance.now();
            
            // Calcula o delta time (tempo desde o último frame), limitando a 45ms para evitar bugs
            let dt = Math.min((now - lastUpdate) / 1000, 0.045);
            lastUpdate = now; // Atualiza o último registro de tempo
        
            // Lógica executada apenas durante o estado de jogo (PLAYING)
            if (gameState === GAME_STATE.PLAYING) {
                // Atualiza a posição do jogador
                updatePlayer(dt);
                
                // Atualiza projéteis do jogador e inimigos
                updateProjectiles(dt);
                updateEnemyProjectiles(dt);
                
                // Atualiza efeitos de explosão e power-ups
                updateExplosions(dt);
                updatePowerUps(dt);
                
                // Lógica de disparo dos inimigos
                enemyFireLogic(dt);
                
                // Atualiza comportamentos específicos da nave-mãe (se existir)
                updateMothership(dt);
        
                // Movimentação oscilatória dos inimigos (efeito "flutuante")
                for (let e of enemies) {
                    if (!e.alive) continue;
                    let t = Math.sin(now / 800 + e.mesh.position.x * 0.7) * 0.7;
                    e.mesh.position.y += Math.sin(now / 1300 + e.mesh.position.x * 0.5) * 0.3 * dt;
                    e.mesh.position.x += t * dt * 0.25;
                }
        
                // Verifica se a wave atual foi concluída
                if (waveEnemies === 0 && !mothership && wave <= maxWaves) {
                    if (wave === maxWaves) {
                        // Wave 10: spawna a nave-mãe
                        spawnMothership();
                        waveEnemies = 1;
                    } else {
                        // Avança para a próxima wave
                        wave++;
                        startWave(wave);
                    }
                }
        
                // Verifica vitória (destruição da nave-mãe)
                if (mothership && !mothership.alive && gameState === GAME_STATE.PLAYING) {
                    // Ativa estado de vitória
                    gameState = GAME_STATE.WIN;
                    playSound('victory');
                    
                    // Mostra overlay de vitória
                    winOverlay = showOverlay(
                        'win', 
                        'VITÓRIA! VOCÊ ANIQUILOU A ARMADA KODAN!', 
                        'Pontuação: ' + playerScore + '<br><br>Tecle R para reiniciar'
                    );
                }
        
                // Verifica recarga de bombas por pontuação
                checkScoreForBombReplenish();
                
                // Atualiza a interface do jogador (HUD)
                updateHUD();
            }
        
            // Renderiza a cena e chama o próximo frame
            renderer.render(scene, camera); // Só isso! Nada de bgCamera ou clear()
            requestAnimationFrame(gameLoop);
            
        }  
        
        // Inicialização do jogo    
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
                            
            // Atualiza câmera 3D (naves)
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            
            // Redimensiona a imagem de fundo
            renderer.setSize(width, height);
        });
        
        window.addEventListener('keydown', keyDown);
        window.addEventListener('keyup', keyUp);

        createRenderer();
        createCamera();
        createScene();
        initBombCounts();
        startOverlay = showOverlay('start', 'O Último Guerreiro Digital das Estrelas', '<span style="font-size:22px;">Tecle ESPAÇO para iniciar</span>');
        gameLoop();
    </script>
</body>
</html>
