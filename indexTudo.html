<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>O Último Guerreiro Digital das Estrelas</title>    

	<style>
		/* === o que já tinha antes === */
	    body { margin: 0; overflow: hidden; }
	    canvas { display: block; }
	
	    /* === NOVO HUD LATERAL (APENAS DURANTE O JOGO) === */
		
		/* PAINEL ESQUERDO */
		#left-panel {
		    position: fixed;
		    left: 12px;
		    top: 12px;
		    width: 150px; /* Largura original */
		    background: rgba(0, 0, 0, 0.7);
		    border-radius: 5px;
		    padding: 10px;
		    color: white;
		    font-family: monospace;
		    z-index: 100;
		}
		
		/* PAINEL DIREITO */
		#right-panel {
		    position: fixed;
		    right: 12px;
		    top: 12px;
		    width: 100px;
		    background: rgba(0, 0, 0, 0.7);
		    border-radius: 5px;
		    padding: 10px;
		    color: white;
		    font-family: monospace;
		    z-index: 100;
		}
		
		/* Títulos (ex: "FASE", "VIDA") */
		.hud-title {
		    font-weight: bold;
		    font-size: 20px;    /* Tamanho */
		    margin-bottom: 10px; /* Espaço após título */
		    color: #0077ff;     /* Azul */
		}
		
		/* Valores (ex: "1/10", "■■■■□") */
		.hud-value {
		    font-size: 16px; /* Tamanho */
		    margin-bottom: 28px; /* Espaço após valor */
		}
		
		/* Bombas (Painel Esquerdo) */
		#bomb-list {
		    margin-left: 5px;
		}
		
		.bomb-entry {
			font-size: 18px;      /* Mesmo tamanho que .hud-value */
		    padding: 4px 10px;    /* Espaço interno ao redor do texto de cada bomba 
			                         1º - espaço vertical (acima e abaixo), 2º - espaço horizontal (esquerda e direita) */
		    margin-bottom: 2px;   /* Espaço externo abaixo de cada linha de bomba (distância entre itens da lista */						
		}

		/* Retângulo que indica qual bomba está selecionada */
		.bomb-selected {
		    background: rgba(0, 119, 255, 0.3);
		    border-left: 2px solid #0077ff;
		}
		
		/* Cores do escudo no HUD */
		#shield-value.ready {
		    color: #00ff88;    /* Verde (3 cargas - pronto) */
		}
		#shield-value.charging {
		    color: #ff9900;    /* Laranja (1-2 cargas - carregando) */
		}
		#shield-value.empty {
		    color: #ff3333;    /* Vermelho (0 cargas - vazio) */
		}
		
	</style>
	
</head>
<body>	

	<!-- HUD DO JOGO (FICA ESCONDIDO ATÉ INICIAR) -->
	<div id="left-panel" class="game-hud" style="display:none;">
	    <div class="hud-title">CAÇA</div>
	    <div class="hud-value">Estelar</div>
	    
	    <div class="hud-title">VLC</div>
	    <div class="hud-value" id="vlc-value">1</div>

		<div class="hud-title">ESCUDO</div>
		<div class="hud-value" id="shield-value">■■■</div>
		
	    <div class="hud-title">MUNIÇÃO</div>
	    <div id="bomb-list"></div>
	</div>
	
	<div id="right-panel" class="game-hud" style="display:none;">
	    <div class="hud-title">FASE</div>
	    <div class="hud-value" id="wave-value">1/10</div>
	    
	    <div class="hud-title">TEMPO</div>
	    <div class="hud-value" id="time-value">00:00</div>
			    
	    <div class="hud-title">PONTOS</div>
	    <div class="hud-value" id="score-value">0</div>
	    
	    <div class="hud-title">VIDA</div>
	    <div class="hud-value" id="health-value">■■■■■</div>
	</div>

	<button 
	    id="unmute" 
	    style="
	        position: fixed;
	        top: 76%;
	        left: 50%;
	        transform: translateX(-50%);
	        z-index: 10000;
	        padding: 8px 15px;
	        background: #0077ff;
	        color: white;
	        border: none;
	        border-radius: 5px;
	        cursor: pointer;
	    "
	>
	    CLIQUE ANTES AQUI PARA ATIVAR O SOM !
	</button>
	
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
	
    <script>    

        			 // ===== [INÍCIO DA SEÇÃO DE SONS DO JOGO] ===== //
	
            let audioEnabled = false;

		// --- CONSTANTES DE MÚSICA/SOM --- //		
            const sounds = {
               // do jogador
                shoot: new Audio('./sounds/shoot2.mp3'),
                lowHealth: new Audio('./sounds/low_health3.mp3'),                
                playerHit: new Audio('./sounds/player_hit.mp3'),
                powerupCollect: new Audio('./sounds/powerup_collect.mp3'),
				booleanShield: new Audio('./sounds/boolean_shield.mp3'),
                lifeBonus: new Audio('./sounds/life_bonus.mp3'),
				shieldHit: new Audio('./sounds/shield_hit2.mp3'),
                
               // dos inimigos                 
                explosion: new Audio('./sounds/explosion.mp3'),
                powerup: new Audio('./sounds/powerup.mp3'),

               // Canhão Quine
                quineCannon: new Audio('./sounds/quine_cannon.mp3'),

               // Nave mãe
				//TBD			   
				   
               // do jogo  
                gameOver: new Audio('./sounds/game_over2.mp3'),
                victory: new Audio('./sounds/victory.mp3'),

			  // Playlist de músicas de fundo (fases normais)
			    playlist: [
			        new Audio('./sounds/trilha1.mp3'),
			        new Audio('./sounds/trilha2.mp3'),
			        new Audio('./sounds/trilha3.ogg')			        
			    ],
				
				playlistQueue: [], // Fila de execução da playlist (Inicializa a fila vazia)
		
			  // Música de fundo para a fase da nave-mãe	
			    mothership: new Audio('./sounds/nave_mae.ogg'),

			 // Váriáveis da playlist
			    currentTrack: null,       // Áudio atual
			    currentTrackIndex: 0,     // Índice da playlist
				
			  // Controle global de volumes:
			    volume: {
			        music: 0.12,     // 10% para músicas de fundo
			        effects: 0.25    // 20% para efeitos (padrão)
    			}
				
            };

			const audioSettings = {
			    isShuffleMode: true,  // true = aleatório | false = sequencial
			    playlistQueue: []     // Fila de músicas (será preenchida dinamicamente)
			};

		
		 // --- FUNÇÕES DE EXECUÇÃO DE MÚSICAS/SOM --- //
		
            function enableAudio() {				
				// Ativa o flag global que permite tocar sons no jogo
                audioEnabled = true; 
				
				// Aplica volumes globais ao ativar
			    sounds.playlist.forEach(audio => audio.volume = sounds.volume.music);
			    sounds.mothership.volume = sounds.volume.music;
				
				if (wave === 10 || (mothership && mothership.alive)) {
			        playMothershipTrack();
			    } else { 
					playPlaylist(); 
				}
            }  
		
            function playSound(name) {				
                // Se o áudio estiver desativado ou não existir, sai da função sem fazer nada
                if (!audioEnabled || !sounds[name]) return;
                // define variável para não ficar chamando sounds várias vezes
                const audio = sounds[name]; 
                // Reinicia apenas se necessário (opcional), se já estiver tocando
                audio.currentTime = 0;
				// Define volume baseado no tipo (música ou efeito)
			    audio.volume = (name === 'mothership' || sounds.playlist.includes(audio)) 
			        ? sounds.volume.music 
			        : sounds.volume.effects;
                                
				audio.play().catch(e => console.log("Erro ao tocar efeito:", e.name, "(Nome:", name + ")"));
            }
        
			function playPlaylist() {
			    // 1. Pausa a música atual (se existir)
			    if (sounds.currentTrack) {
			        sounds.currentTrack.pause();
			        sounds.currentTrack.currentTime = 0;
			    }
								
				// 2. Se não há fila OU a música atual acabou, recria a fila
    			if (audioSettings.playlistQueue.length === 0) {
			        audioSettings.playlistQueue = [...sounds.playlist]; // Cópia da playlist original
			
			        // Embaralha a fila se estiver em modo aleatório
			        if (audioSettings.isShuffleMode) {
			            shuffleArray(audioSettings.playlistQueue);
			        }
			    }
			
			    // 3. Pega a próxima música da fila
			    const track = audioSettings.playlistQueue.shift(); // Remove o primeiro item
			    sounds.currentTrack = track;
			
			    // 4. Toca e prepara a próxima
			    track.loop = false;
			    track.play()
			        .then(() => {
			            track.onended = () => { //playPlaylist(); // Chama a próxima ao terminar
							if (gameState === GAME_STATE.PLAYING) playPlaylist(); // Só continua se o jogo estiver ativo
						};
			        })
			        .catch(e => console.log("Erro ao tocar:", e));
			}

			function shuffleArray(array) {
			    for (let i = array.length - 1; i > 0; i--) {
			        const j = Math.floor(Math.random() * (i + 1));
			        [array[i], array[j]] = [array[j], array[i]];
			    }
			}
		
			function playMothershipTrack() {
			    if (sounds.currentTrack && sounds.currentTrack !== sounds.mothership) {
			        sounds.currentTrack.pause();
			        sounds.currentTrack.currentTime = 0;
			        sounds.currentTrack.onended = null;
			    }
			
			    sounds.mothership.loop = true;
			    sounds.mothership.volume = sounds.volume.music; // Usa volume centralizado
			    sounds.mothership.play()
			        .then(() => sounds.currentTrack = sounds.mothership)			        
					.catch(e => console.log("Erro ao tocar nave-mãe:", e.name));
			}

	        // TBD	
			document.getElementById('unmute').addEventListener('click', function() {
			    // 1. Esconde o botão IMEDIATAMENTE (antes de qualquer lógica)
			    this.style.display = 'none';			    
			    // 2. Habilita o áudio (chama enableAudio())
			    enableAudio();			
			});
		
         			// ===== [FIM DA SEÇÃO DE SONS DO JOGO] ===== //
             
        
        // ===== [DEFINIÇÃO DOS ESTADOS DO JOGO] ===== //
        const GAME_STATE = {
            START: 0,      // Estado inicial (tela de título)
            PLAYING: 1,    // Jogo em andamento
            PAUSED: 2,     // Jogo pausado
            GAME_OVER: 3,  // Derrota (exibindo tela de game over)
            WIN: 4         // Vitória (inimigos derrotados)
        };

		// ===== [VARIÁVEIS DE TEMPO] ===== //
		let gameStartTime = 0;  // Etiqueta de tempo do início do jogo
		let elapsedTime = 0;    // Tempo acumulado em segundos

        // ===== [CONTROLE DE WAVES/FASES] ===== //
        let wave = 1,       // Fase atual (começa na wave 1)
            maxWaves = 10,  // Número total de waves (última é a nave-mãe com escolta)
            waveEnemies = 0; // Contador de inimigos restantes na wave atual

        // ===== [ TIPOS DE "BOMBAS" (OPERADORES LÓGICOS)  ] ===== //         
        const OPERATORS = [
            { key: 'AND',  fn: (a, b) => a & b },
            { key: 'OR',   fn: (a, b) => a | b },
            { key: 'XOR',  fn: (a, b) => a ^ b },           
            { key: 'NAND', fn: (a, b) => 1 - (a & b) },
            { key: 'NOR',  fn: (a, b) => 1 - (a | b) },
            { key: 'XNOR', fn: (a, b) => 1 - (a ^ b) }
        ];

      // ===== [ TIPOS DE INIMIGOS (NAVES E SUAS CARACTERÍSTICAS) ] ===== //

      //  Nível	    Tipo de Nave	           Comportamento Esperado	             Intervalo
      //  ---------------------------------------------------------------------------------------
      //   1		Caças estáticos        	Valor lógico não muda depois de gerado       X  
      //   2		Caças dinâmicos	      	Valor lógico muda aleatoriamente (0/1)	     3s
      //   3		Caças VLC	          	Alterna entre VLC e !VLC do jogador          4s
      //   4		Cruzadores estáticos   	Valor lógico não muda depois de gerado       X  
      //   5		Cruzadores dinâmicos	Valores A e B mudam aleatoriamente	         5s
      //   6		Cruzadores VLC	      	A fixo, B alterna entre VLC e !VLC	         4s
      //   7		Destroyers estáticos   	Valor lógico não muda depois de gerado       X  
      //   8		Destroyers dinâmicos	Expressões complexas com A e B dinâmicos	 5s
      //   9		Nave-Mãe	            Geradores A e B mudam aleatoriamente	     5s
      //  --------------------------------------------------------------------------------------
            
        const ENEMY_TYPES = [
            
        // --- NÍVEL 1 (caças, com valor lógico constante, gearado aleatoriamente)
            
            {   shape: 'cube', ev: () => Math.round(Math.random()),   // define nave, gera valor lógico de forma aleatória
                isDynamic: false  // valor não muda após ser gerado
            },

            
        // --- NÍVEL 2 (caças, com valor mudando a cada "changeInterval" segundos, gearado aleatoriamente)
            
            {   shape: 'cube', ev: () => Math.round(Math.random()),  // define nave, gera valor lógico de forma aleatória
                isDynamic: true, changeInterval: 3  // muda o valor a cada 3 segundos
            },

            
         // --- NÍVEL 3 (caças, com valor mudando a cada "changeInterval" segundos, condicionado ao VLC ou seu contraditório)
                        
            {
                shape: 'cube',  // define nave,
                ev: function() { 
                    const vlc = getSafeVLC(); // <-- Usa a função segura
                    return Math.random() > 0.5 ? vlc : 1 - vlc;  //gera valor com 50% de chance de ser vlc ou !vlc
                },
                isDynamic: true, changeInterval: 4  // muda o valor a cada 4 segundos
            },

            
        // --- NÍVEL 4 (cruzadores, com expressão básicas, com valor de A e B constante, gerados aleatoriamente)

            // 1) Operação AND
            {     shape: 'tetra', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),
                  ev: function() { return this.A() & this.B(); },  // Cálculo real: A AND B
                  ab: true, expr: 'A.B', // Exibição visual
                  isDynamic: false  // não muda os valores de A e B
            },

            // 2) Operação OR
            {   shape: 'tetra', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),
                ev: function() { return this.A() | this.B(); }, // Cálculo real: A OR B
                ab: true, expr: 'A+B', // Exibição visual
                isDynamic: false  // não muda os valores de A e B
            },

            // 3) Operação XOR
            {   shape: 'tetra', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),
                ev: function() { return this.A() ^ this.B(); }, // Cálculo real: A XOR B
                ab: true, expr: 'A⊕B',  // Exibição visual
                isDynamic: false  // não muda os valores de A e B
            },
                        
        
        // --- NÍVEL 5 (cruzadores, com expressão simples, com valor de A e B gerado aleatoriamente, mudando a cada "changeInterval" segundos)

            // 1) Operação AND
            {     shape: 'tetra', A: () => Math.round(Math.random()),  B: () => Math.round(Math.random()),
                  ev: function() { return this.A() & this.B(); }, // Cálculo real: A AND B
                  ab: true, expr: 'A.B', // Exibição visual
                  isDynamic: true, changeInterval: 5  // muda o valor a cada 5 segundos
            },

            // 2) Operação OR
            {     shape: 'tetra', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),
                  ev: function() { return this.A() | this.B(); }, // Cálculo real: A OR B
                  ab: true, expr: 'A+B', // Exibição visual
                  isDynamic: true,  changeInterval: 5  // muda o valor a cada 3 segundos
            },

            // 3) Operação XOR
            {     shape: 'tetra', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),
                  ev: function() { return this.A() ^ this.B(); }, // Cálculo real: A XOR B
                  ab: true, expr: 'A⊕B', // Exibição visual
                  isDynamic: true,  changeInterval: 5  // muda o valor a cada 3 segundos 
            },

        
        // --- NÍVEL 6 (cruzadores, com expressões básicas, A fixo, B dinâmico = VLC ou !VLC), ambos mudando de tempos em tempos

            // 1) Operação AND            
            {   shape: 'tetra', 
                A: () => Math.round(Math.random()), // gerado aleatoriamente                
                B: function() { 
                    return Math.random() > 0.5 ? getSafeVLC() : 1 - getSafeVLC(); // Recalcula sempre que chamada (dinâmico + reage ao playerVLC)
                },
                ev: function() { return this.A() & this.B(); }, // Cálculo A.B
                ab: true, expr: 'A.B',   // Exibição visual
                isDynamic: true, changeInterval: 4   // muda os valores de A e B a cada 4 segundos
            },

            // 2) Operação OR 
            {   
                shape: 'tetra',
                A: () => Math.round(Math.random()), 
                B: function() { 
                    return Math.random() > 0.5 ? getSafeVLC() : 1 - getSafeVLC(); // Recalcula sempre que chamada (dinâmico + reage ao playerVLC)
                },
                ev: function() { return this.A() | this.B(); }, // Cálculo A+B
                ab: true, expr: 'A+B', // Exibição visual
                isDynamic: true, changeInterval: 4   // muda os valores de A e B a cada 4 segundos
            },

            // 3) Operação XOR
            {   
                shape: 'tetra',
                A: () => Math.round(Math.random()),                
                B: function() { 
                    return Math.random() > 0.5 ? getSafeVLC() : 1 - getSafeVLC(); // Recalcula sempre que chamada (dinâmico + reage ao playerVLC)
                },
                ev: function() { return this.A() ^ this.B(playerVLC); }, // Cálculo A⊕B
                ab: true, expr: 'A⊕B', // Exibição visual
                isDynamic: true, changeInterval: 4    // muda os valores de A e B a cada 4 segundos
            },
        
        // --- NÍVEL 7 (destroyers, com expressão complexas, com valor de A e B gerado aleatoriamente, que fica constante)
        
            // 1) (NOT A OR NOT B) → Lei de De Morgan equivalente a NAND
            { shape: 'octahedron', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),  // define nave, gera A e B de forma aleatória
              ev: function() { return (1 - this.A()) | (1 - this.B()); },  // Cálculo real
              ab: true, expr: '(!A)+(!B)', // Exibição visual
              isDynamic: false  // valores de A e B não mudam após serem gerados
            },
                    
            // 2) (NOT A AND NOT B) → Lei de De Morgan equivalente a NOR
            { shape: 'octahedron', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()), // define nave, gera A e B de forma aleatória
              ev: function() { return (1 - this.A()) & (1 - this.B()); },  // Cálculo real
              ab: true, expr: '(!A).(!B)', // Exibição visual
              isDynamic: false  // valores de A e B não mudam após serem gerados
            },
        
            // 3) (NOT A AND B) OR (NOT B AND A) → equivalente ao XOR de A e B            
            { shape: 'octahedron', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),  // define nave, gera A e B de forma aleatória                            
              ev: function() { return ((1 - this.A()) & this.B()) | (this.A() & (1 - this.B())); },  // cálculo real
              ab: true, expr: '(!A.B)+(A.!B)', // Exibição visual
              isDynamic: false  // valores de A e B não mudam após serem gerados
            },       

        // --- NÍVEL 8 (destroyers, com expressão complexas, com valor de A e B gerado aleatoriamente, mudando de tempos em tempos)
        
            // 1) (NOT A OR NOT B) → Lei de De Morgan equivalente a NAND
            { shape: 'octahedron', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),  // define nave, gera A e B de forma aleatória
              ev: function() { return (1 - this.A()) | (1 - this.B()); },  // Cálculo real
              ab: true, expr: '(!A)+(!B)', // Exibição visual
              isDynamic: true, changeInterval: 5     // muda os valores de A e B a cada 5 segundos
            },
                    
            // 2) (NOT A AND NOT B) → Lei de De Morgan equivalente a NOR
            { shape: 'octahedron', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()), // define nave, gera A e B de forma aleatória
              ev: function() { return (1 - this.A()) & (1 - this.B()); },  // Cálculo real
              ab: true, expr: '(!A).(!B)', // Exibição visual
              isDynamic: true, changeInterval: 5     // muda os valores de A e B a cada 5 segundos
            },
        
            // 3) (NOT A AND B) OR (NOT B AND A) → equivalente ao XOR de A e B            
            { shape: 'octahedron', A: () => Math.round(Math.random()), B: () => Math.round(Math.random()),  // define nave, gera A e B de forma aleatória              
              ev: function() { return ((1 - this.A()) & this.B()) | (this.A() & (1 - this.B())); },  // cálculo real
              ab: true, expr: '(!A.B)+(A.!B)', // Exibição visual
              isDynamic: true, changeInterval: 5     // muda os valores de A e B a cada 5 segundos
            },

        // --- Nível 9: NAVE-MÃE
            {
              shape: 'octahedron', size: 3.0,
              generators: [], // Inicializa vazio (será preenchido em spawnMothership())
              ev: function() {          
                  const A = this.generators[0].value;
                  const B = this.generators[1].value;
                  return (A ^ B) & playerVLC;    // C = VLC do jogador
              },
              expr: '(A⊕B).C',
              isBoss: true,
              health: 12 + maxWaves
            }
            
        ];       
        
        // ===== [ CONSTANTES DE CORES E CONFIGURAÇÕES VISUAIS ] ===== //
        const PLAYER_COLOR = 0x0077ff;          // Cor azul do jogador (hexadecimal)
        const ENEMY_COLOR = 0xff3300;           // Cor vermelha dos inimigos
        const PROJECTILE_COLOR = 0xffffff;      // Cor branca dos projéteis do jogador
        const ENEMY_PROJECTILE_COLOR = 0xff2200;// Cor vermelha dos projéteis inimigos
        const POWERUP_COLOR = 0x00ff00;         // Cor verde dos power-ups
        
        // ===== [ CONSTANTES DA AREA DO JOGO ] ===== //
        const PLAY_AREA = { x: 30, y: 26 };     	// Dimensões da área jogável (unidades 3D)  o dobro do original = x: 16, y: 10
		const ENEMY_LIMIT_Y = -PLAY_AREA.y * 0.66;  // Limite de avanço vertical das naves inimigas (2/3 da tela, abaixo do centro)

        // ===== [ VARIÁVEIS DE RENDERIZAÇÃO ] ===== //
        let renderer, scene, camera;            // Objetos principais do Three.js
        let width = window.innerWidth,          // Largura da janela
            height = window.innerHeight;        // Altura da janela

               
        // ===== [ ESTADO DO JOGO ] ===== //
        let gameState = GAME_STATE.START;       // Controla o estado atual (início/jogando/game over)

        
        // ===== [ VARIÁVEIS DO JOGADOR ] ===== //
		const SHIELD_MAX_CHARGE = 5;		// Carga máxima de proteção do escudo booleano
        let player,                         // Objeto com posição/speed do jogador
            playerVLC = 1,                  // Valor lógico atual do jogador (0 ou 1)
            playerHealth = 5,               // Vida atual
            playerMaxHealth = 5,            // Vida máxima
            playerScore = 0,                // Pontuação
			playerShield = false,         	// Estado do escudo (ativo/inativo)  
			shieldCharge = SHIELD_MAX_CHARGE,	// Carga inicial do escudo			
			shieldCooldown = 60,         	// Tempo de recarga (segundos)
			shieldTimer = 0,             	// Contador de tempo para recarga
			shieldAura;                     // Aura do escudo booleano
        window.playerVLC = playerVLC; 		// cria uma referência global
		
        // ===== [ OBJETOS 3D DO JOGADOR ] ===== //
        let playerShip,                         // Malha 3D da nave
            playerThruster,                     // Efeito de propulsão
            playerVLCMesh,                      // Sprite do valor lógico (VLC)
            playerHealthBar;                    // Barra de vida flutuante
        
        // ===== [ ARRAYS DE ENTIDADES ] ===== //
        let enemies = [],                       // Lista de inimigos ativos
            projectiles = [],                   // Projéteis do jogador
            enemyProjectiles = [],              // Projéteis inimigos
            explosions = [],                    // Efeitos de explosão
            powerUps = [];                      // Power-ups coletáveis
        
        // ===== [ CONTROLES E OPERADORES ] ===== //
        let operatorIndex = 0;                  // Índice do operador lógico selecionado
        
        // ===== [ SISTEMA DE BOMBAS ] ===== //
        const INITIAL_BOMB_COUNT = 15;          // Quantidade inicial de bombas (não usado diretamente)
        let bombCounts = {};                    // Contagem de bombas por operador (ex: { AND: 10 })
        let bombReplenishedAtScore = {};        // Pontuações que já deram recarga de bombas
        
        // ===== [ INPUT ] ===== //
        let keys = {};                          // Rastreia teclas pressionadas ({ KeyA: true/false })
        
        // ===== [ ELEMENTOS VISUAIS ] ===== //
        let stars = [];                         // Partículas de estrelas de fundo
        let hud = {};                           // Elementos de UI (health, score, etc) criados dinamicamente            
          
        
        // ===== [ OVERLAYS DE TELA ] ===== //
        let pauseOverlay,                       // Tela de pausa
            startOverlay,                       // Tela inicial
            gameOverOverlay,                    // Tela de game over
            winOverlay;                         // Tela de vitória
        
        // ===== [ TIMERS ] ===== //
        let lastFire = 0,                       // Último momento que o jogador atirou
            fireDelay = 0.25;                   // Atraso entre tiros (segundos)
        let lastEnemyFire = 0,                  // Último tiro inimigo
            enemyFireDelay = 1.5;               // Atraso entre tiros inimigos
        let lastUpdate = performance.now();     // Timestamp da última atualização (para cálculo de deltaTime)
        

        // Inicializa os contadores de bombas
        function initBombCounts() {
            OPERATORS.forEach(op => {          
                bombCounts = {
                    'AND' : 12,
                    'OR'  : 6,
                    'XOR' : 9,
                    'NAND': 9,
                    'NOR' : 15,
                    'XNOR': 12
                };
                bombReplenishedAtScore = {};                
            });
        }
        
        function createRenderer() {
            renderer = new THREE.WebGLRenderer({ antialias: true });   
            renderer.setSize(width, height);
            document.body.appendChild(renderer.domElement);            
        }

        function createCamera() {
            camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 100);
            //camera.position.set(0, 0, 22);  // x,y,z
            camera.position.set(0, -4, 25);  // x (movimento radial) ,y (movimento de elevação), z (movimento em inclinação)
            camera.lookAt(0, 0, 0); // Foco no centro da cena            
        }
        
        function createScene() {
            scene = new THREE.Scene();   // Cria a cena primeiro!
        
            // 1. Carrega a imagem de fundo (cobre toda a tela automaticamente)
            new THREE.TextureLoader().load(
                './figs/space_background_horizontal2.png',
                (texture) => {
                    scene.background = texture; // Fundo estático e fixo
                    console.log("Fundo carregado!");
                },
                undefined, // Barra de progresso (opcional)
                (error) => {
                    console.error("Erro no fundo:", error);
                    scene.background = new THREE.Color(0x0a0e2a); // Fallback se a imagem falhar
                }
            );
        
            // 2. Adicione as luzes
            let ambient = new THREE.AmbientLight(0xffffff, 0.7);
            let dir = new THREE.DirectionalLight(0xffffff, 0.8);
            dir.position.set(0, 0, 10);
            scene.add(ambient, dir);
        }

        
        function createPlayer() {
            // Primeiro, cria o objeto 'player' com as posições iniciais
            player = {
                x: 0,
                y: -PLAY_AREA.y / 2.2,
                speed: 7.5
            };
        
            // Depois, cria a nave e o VLC usando player.x e player.y
           /* let geo = new THREE.ConeGeometry(0.6, 1.6, 5);
            let mat = new THREE.MeshLambertMaterial({ color: PLAYER_COLOR });
            playerShip = new THREE.Mesh(geo, mat);*/
			// Adicione:
			const textureLoader = new THREE.TextureLoader();
			const playerTexture = textureLoader.load('./figs/starleague_fighter.webp');
			const playerMaterial = new THREE.SpriteMaterial({ 
			    map: playerTexture,
			    transparent: true 
			});
			playerShip = new THREE.Sprite(playerMaterial);
			playerShip.scale.set(4, 4, 1); // Ajuste a escala conforme necessário
			
            playerShip.rotation.z = Math.PI;  // rotaciona a imagem de 180º
            playerShip.position.set(player.x, player.y, 0); // Usa player.x e player.y
            scene.add(playerShip);			
			
            // Cria thruster e barra de vida (health bar)
            let thrusterGeo = new THREE.CylinderGeometry(0.18, 0.01, 0.4, 8);
            let thrusterMat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.7 });
            playerThruster = new THREE.Mesh(thrusterGeo, thrusterMat);
            playerThruster.position.set(0, -0.95, 0);
            playerThruster.rotation.x = Math.PI / 2;
            playerShip.add(playerThruster);  // adiciona o Thruster à nave
        
            playerHealthBar = createBar(1.5, 0.12, 0x00ff55, 0.2);
            playerHealthBar.position.set(0, 0.6, 0);  // playerHealthBar.position.set(0, 1.2, 0);
			playerHealthBar.scale.set(0.25, 0.25, 0.25); // Para compensa o scaling da nave
            playerShip.add(playerHealthBar);  // adiciona a barra de vida à nave

			// Cria a aura do escudo  
			shieldAura = new THREE.Mesh(  
			    new THREE.RingGeometry(0.5, 0,7, 32),  // argumentos: (Raio interno, Raio externo, Segmentos). Segmentos diz sobre suavidade do anel
			    new THREE.MeshBasicMaterial({ 
					color: 0x00ffff, 		// Cor ciano
					transparent: true, 		// transparência
					opacity: 0.5 			// 50% de transparência
				})  
			);
			playerShip.add(shieldAura); 	// adiciona o escudo à nave 
			shieldAura.visible = false; 	// o escudo começa invisível

            // Agora o VLC pode usar player.x e player.y sem erro
            playerVLCMesh = createVLCMesh(playerVLC);
            playerVLCMesh.position.set(player.x - 1, player.y + 2.2, 0); // Posição correta desde o início
            scene.add(playerVLCMesh);
        }

        
        function createVLCMesh(val) {
            let canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            let ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 128, 128);
            ctx.font = 'bold 88px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = val ? '#0090ff' : '#ff2222';
            ctx.shadowBlur = 12;
            ctx.fillStyle = val ? '#0090ff' : '#ff2222';
            ctx.fillText(val ? '1' : '0', 64, 64);
            let tex = new THREE.CanvasTexture(canvas);
            let mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
            let sprite = new THREE.Sprite(mat);
            sprite.scale.set(0.9, 0.9, 1);
            sprite.vlcValue = val;
            return sprite;
        }

        function updateVLCMesh(val) {
            let sprite = playerVLCMesh;
            let canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            let ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 128, 128);
            ctx.font = 'bold 88px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = val ? '#0090ff' : '#ff2222';
            ctx.shadowBlur = 12;
            ctx.fillStyle = val ? '#0090ff' : '#ff2222';
            ctx.fillText(val ? '1' : '0', 64, 64);
            sprite.material.map.image = canvas;
            sprite.material.map.needsUpdate = true;
            sprite.vlcValue = val;
        }

        function createBar(w, h, color, border) {
            let group = new THREE.Group();
            let bgGeo = new THREE.PlaneGeometry(w + border, h + border);
            let bgMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
            let bg = new THREE.Mesh(bgGeo, bgMat);
            group.add(bg);
            let fgGeo = new THREE.PlaneGeometry(w, h);
            let fgMat = new THREE.MeshBasicMaterial({ color: color });
            let fg = new THREE.Mesh(fgGeo, fgMat);
            fg.position.z = 0.01;
            fg.name = 'bar';
            group.add(fg);
            return group;
        }

        function setBarValue(bar, frac) {
            let fg = bar.children.find(m => m.name === 'bar');
            fg.scale.x = Math.max(0.01, frac);
            fg.position.x = -(1 - frac) * (fg.geometry.parameters.width / 2);
        }

        function getSafeVLC() {
            return window.playerVLC ?? 1; // Garante sempre 0 ou 1
        }

		
        function spawnEnemy(type, x, y) {
		    let mesh;
		
		    // ==================== [1. DEFINE VIDA POR TIPO DE NAVE] ====================
		    let health;
		    if (type.shape === 'cube') {  // Caças
		        health = 2 + Math.floor(wave * 0.5);  // Wave 1 = 2
		    } else if (type.shape === 'tetra') {  // Cruzadores
		        health = 3 + Math.floor(wave * 0.7);  // Wave 5 = 6
		    } else if (type.shape === 'octahedron') {  // Destroyers
		        health = 4 + Math.floor(wave * 1.0);  // Wave 7 = 11
		    }
		    health = Math.max(health, 3);  // Garante vida mínima = 3
		
		    // ==================== [2. CRIA GEOMETRIA] ===================================
		    if (type.shape === 'cube') {
		        mesh = new THREE.Mesh(
		            new THREE.BoxGeometry(1, 1, 1),
		            new THREE.MeshLambertMaterial({ color: ENEMY_COLOR })
		        );
		    } else if (type.shape === 'tetra') {
		        mesh = new THREE.Mesh(
		            new THREE.TetrahedronGeometry(0.7),
		            new THREE.MeshLambertMaterial({ color: ENEMY_COLOR })
		        );
		    } else if (type.shape === 'octahedron') {
		        mesh = new THREE.Mesh(
		            new THREE.OctahedronGeometry(0.8),
		            new THREE.MeshLambertMaterial({ 
		                color: ENEMY_COLOR,
		                emissive: 0xff3300,
		                emissiveIntensity: 0.3
		            })
		        );
		    }
		    mesh.position.set(x, y, 0);
		
		    // ===== [3. BARRA DE VIDA] =================================================
		    let healthBar = createBar(1.1, 0.11, 0xff4444, 0.18);
		    healthBar.position.set(0, -0.8, 0);
		    mesh.add(healthBar);

			// ===== [4. INICIALIZAÇÃO DOS VALORES LÓGICOS] ====================== 
		    let ab = type.ab;
		    let A = ab ? (type.A ? type.A() : Math.round(Math.random())) : null;
		    let B = ab ? (type.B ? type.B(playerVLC) : Math.round(Math.random())) : null;
		
		    // Cálculo de 'ev' com garantia de sincronia
		    let ev;
		    if (type.ev) {
		        const context = { 
		            A: () => A, 
		            B: () => B,
		            generators: type.generators || [] 
		        };
		        ev = type.isDynamic 
		            ? () => type.ev.call(context)  // Dinâmico: função que recalcula
		            : type.ev.call(context);     // Estático: valor fixo
		    } else {
		        ev = (A !== null && B !== null) 
		            ? eval(type.expr.replace('.', '&').replace('+', '|').replace('⊕', '^'))
		            : 0;
		    }
			
			// ===== [5. PERFIL DE MOVIMENTO DAS NAVES] ============================
			let movementType;
			// Define o movimento baseado no formato da nave (shape)
			if (type.shape === 'cube') movementType = 'fighter';      			// Caças
			else if (type.shape === 'tetra') movementType = 'cruiser'; 			// Cruzadores  
			else if (type.shape === 'octahedron') movementType = 'destroyer'; 	// Destroyers
			if (type.isBoss) movementType = 'mothership';            			// Nave-mãe

			
		    // ==================== [6. CRIA SPRITE DE EXPRESSÃO] ====================
		    let evText = type.expr || (typeof ev === 'function' ? ev().toString() : ev.toString());			
		    let evMesh = createEVSprite(evText, A, B, type.expr);
			
		    evMesh.position.set(0, 1.2, 0);
		    mesh.add(evMesh);
		    scene.add(mesh);
		
		    return {
		        mesh,           					// Objeto 3D da nave inimiga
                health,         					// Vida atual do inimigo
                maxHealth: health, 					// Vida máxima (igual à inicial)
                healthBar,      					// Barra de vida flutuante
                ev,             					// Valor lógico atual (0 ou 1)
                evMesh,         					// Sprite com a expressão lógica (ex: "A+B")
                ab,             					// Flag que indica se tem variáveis A/B
                A,              					// Valor da variável A (se existir)
                B,              					// Valor da variável B (se existir)
                expr: type.expr, 					// Expressão textual (ex: "A+B")
                alive: true,    					// Status do inimigo (vivo/morto)
                type,           					// Referência ao tipo original (ENEMY_TYPES)
                changeTimer: 0, 					// Contador para mudanças dinâmicas
                isDynamic: type.isDynamic || false, // Flag de comportamento dinâmico (herdado do tipo)
				movementType 						// Perfil de movimento das naves inimigas
		    };
		}
        

        function updateDynamicEnemies(dt) {
                
            for (let e of enemies) {
                
                // Garante que a nave é dinâmica e tem intervalo        
                if (!e.alive || !e.isDynamic || !e.type.changeInterval) continue;

                // Atualiza o timer do inimigo
                e.changeTimer = (e.changeTimer || 0) + dt;

                // Se o tempo atual for ao menos igual a tempo de mudança...
                if (e.changeTimer >= e.type.changeInterval) {

                    // Reseta o timer
                    e.changeTimer = 0;
                    
                    // Atualiza A e B (se existirem)
                    if (e.type.A) e.A = e.type.A();
                    if (e.type.B) e.B = e.type.B(playerVLC); // Passa playerVLC se necessário
                    
                    // Recalcula ev (usando a expressão ou função ev)                   
					e.ev = e.type.ev(); // SEMPRE usa a função definida no tipo do inimigo
                    
                    // Atualiza o sprite da expressão (HUD)
                    updateEnemyEVSprite(e);
                }
            }
        }
        
        function updateEnemyEVSprite(enemy) {
            // Remove o sprite antigo
            enemy.mesh.remove(enemy.evMesh);
        
            // Cria texto que ficará acima da nave: expressão se houver ou valor lógico da nave
            let evText = enemy.expr || enemy.ev?.toString(); 
            
            // Cria um novo sprite com os valores atualizados
            enemy.evMesh = createEVSprite(
        		evText,     // texto  que será exibido acima da nave inimiga(ex: "A+B" ou "1" ou "0")
        		enemy.A,    // Valor atual de A (ou null)
        		enemy.B,    // Valor atual de B (ou null)
        		enemy.expr  // Texto da expressão
        	);
        
            // Posiciona o sprite acima da nave
            enemy.evMesh.position.set(0, 1.2, 0);
            enemy.mesh.add(enemy.evMesh);
        }
        
        function spawnMothership() {
			
            const type = ENEMY_TYPES.find(t => t.isBoss);
            const mothership = spawnEnemy(type, 0, PLAY_AREA.y/2.5);                        
            mothership.mesh.scale.set(1.5, 1.5, 1.5);  // Expansão
            
            // Adiciona geradores
            mothership.generators = [ // Preenche os geradores aqui
                { label: 'A', value: Math.round(Math.random()) },
                { label: 'B', value: Math.round(Math.random()) }
            ];
            
            return mothership;
        }

		
		function updateMothership(dt) {
			
		    // 1. Verifica se a nave-mãe existe e está viva. Se não, sai da função.
		    if (!mothership || !mothership.alive) return;
		
		    // 2. Incrementa o timer de atualização com o tempo passado desde o último frame (dt).
		    //    Se changeTimer for undefined (primeira execução), inicia com 0.
		    mothership.changeTimer = (mothership.changeTimer || 0) + dt;
		
		    // 3. Verifica se passaram 5 segundos desde a última atualização:
		    if (mothership.changeTimer >= 5) {
		        // 4. Reseta o timer para a próxima contagem:
		        mothership.changeTimer = 0;
		
		        // 5. Atualiza o gerador A com um valor aleatório (0 ou 1):
		        mothership.generators[0].value = Math.round(Math.random());
		
		        // 6. Atualiza o gerador B com um valor aleatório (0 ou 1):
		        mothership.generators[1].value = Math.round(Math.random());
		
		        // 7. Recalcula o valor lógico (ev) da nave-mãe usando a função definida em ENEMY_TYPES:
		        //    - Acessa mothership.type.ev(), que calcula (A⊕B).C automaticamente, onde C = VLC do jogador
		        mothership.ev = mothership.type.ev();
		
		        // 8. Atualiza o HUD visual da nave-mãe com os novos valores (A, B, ev):
		        updateEnemyEVSprite(mothership);
		    }
		}

		
        function createEVSprite(text, A, B, expr) {

            // Adicione no início da função:
            A = A !== undefined ? A : null;
            B = B !== undefined ? B : null;
            text = text || (A !== null && B !== null ? `${A} ${expr} ${B}` : '?');
            
                    //      Visualização das áreas a serem criadas: 
                         
                    //                Canvas (256x164px)
                    //            +---------------------------+
                    //            |                           |
                    //            |   Expressão (y=40)        |  ← Texto principal ("A.B", "A+B", etc.)
                    //            |                           |
                    //            |   +-------------------+   |  ← fillRect(20,75,216,70)
                    //            |   |  A = 1  B = 0     |   |  ← Texto das variáveis (y=110)
                    //            |   +-------------------+   |
                    //            |                           |
                    //            +---------------------------+
            
            // Cria um canvas HTML para renderizar o texto
            const canvas = document.createElement('canvas');
            canvas.width = 256;  // Largura do canvas
            canvas.height = 164; // Altura do canvas
            const ctx = canvas.getContext('2d'); // Contexto 2D para desenho
                                        
            // Configuração da EXPRESSÃO PRINCIPAL (texto amarelo)
            ctx.font = 'bold 70px Arial';      // Tamanho e tipo da Fonte, em negrito
            ctx.textAlign = 'center';          // Alinhamento centralizado
            ctx.textBaseline = 'middle';       // Alinhamento vertical no meio
            ctx.fillStyle = "#ffff55";         // Cor amarela
            ctx.shadowColor = '#000';          // Sombra preta
            ctx.shadowBlur = 8;                // Intensidade da sombra
            const exprX = canvas.width/2;      // Posição horizontal no canvas; no meio da largura do canvas
            const exprY = 40;                  // Posição vertital no canvas
            ctx.fillText(text, exprX, exprY);  // Desenha o texto nas coordenadas

            // Obs:
            //   como temos "center", O texto é centralizado horizontalmente em torno do valor de exprX (desejável: x seja o meio da largura do canvas)
            //   como temos "middle", Altura do das letras do texto são centralizadas verticalmente em torno do valor de exprY

                     //           Centro Horizontal (x=128)
                     //                     ↓
                     //       +---------------------------+  ← Borda Superior (y=0)
                     //       |                           | 
                     //       |                           |
                     //       |          [Texto]          | ← y=40 (altura média do texto aqui)
                     //       |                           |
                     //       |                           | 
                     //       +---------------------------+ ← Borda Inferior (y=164)
            
            // Se houver variáveis (A, B) e expressão (expr), desenha o fundo e os valores
            if (A !== null && B !== null && expr) {
                // Fundo semi-transparente para as variáveis
                ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                
               //parâmetros do retangulo: ctx.fillRect(x, y, largura, altura)
                const rectWidth = 245;  // Largura em (px) do quadrado. Deve ser menor que a largura do canvas
                const rectHeight = 70;  // Altura em (px) do quadrado.
                const rectX = (canvas.width - rectWidth) / 2; // posição x: para ficar centralizado com a expressão.
                const rectY = exprY + 40;  // para ficar 40 pontos abaixo da posição da expressão.                
                ctx.fillRect(rectX, rectY, rectWidth, 70);                
                
                // Variáveis (A e B em verde)
                ctx.font = 'bold 48px Arial';  // Fonte menor que a da expressão
                ctx.fillStyle = "#55ff55";      // Cor verde
                ctx.shadowBlur = 0;            // Remove sombra                
                ctx.fillText(`A = ${A}  B = ${B}`, 128, 115); // Ajusta Y para 110 (centralizado no novo fundo)
            }
        
            // Converte o canvas em uma textura para Three.js
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(3.2, 2.0, 1); // Escala do sprite (3.2 unidades de largura, 2.0 de altura)
            return sprite;
        }

        
        function spawnProjectile(x, y, dx, dy, operator) {            
            playSound('shoot'); // Toca o som do disparo
                    
            // Cria a geometria do projétil (cilindro fino)
            let geo = new THREE.CylinderGeometry(0.15, 0.15, 0.7, 10);
            
            // Material branco e emissivo (para brilho)
            let mat = new THREE.MeshBasicMaterial({ color: PROJECTILE_COLOR, emissive: PROJECTILE_COLOR });            
            
            // Cria a malha 3D e posiciona
            let mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = Math.PI / 2; // Rotaciona para ficar horizontal
            mesh.position.set(x, y + 0.8, 0.05); // Posição ligeiramente acima do jogador (y + 0.8)
            
            scene.add(mesh); // Adiciona à cena
            projectiles.push({ mesh, dx, dy, operator, alive: true }); // Armazena no array
        }

        
        function spawnEnemyProjectile(x, y, dx, dy) {
            // Cria a geometria de um cilindro para o projétil:
            // - Raio superior/inferior: 0.14 (tamanho da base)
            // - Altura: 0.5 (comprimento do projétil)
            // - Segmentos: 8 (suavidade do cilindro)
            let geo = new THREE.CylinderGeometry(0.14, 0.14, 0.5, 8);
        
            // Define o material do projétil:
            // - Cor: ENEMY_PROJECTILE_COLOR (vermelho, definido nas constantes)
            // - Não emite luz (MeshBasicMaterial)
            let mat = new THREE.MeshBasicMaterial({ color: ENEMY_PROJECTILE_COLOR });
        
            // Combina geometria + material em um objeto 3D (malha)
            let mesh = new THREE.Mesh(geo, mat);
        
            // Rotaciona o projétil 90 graus no eixo X (para ficar "deitado")
            mesh.rotation.x = Math.PI / 2; // π/2 radianos = 90°
        
            // Posiciona o projétil:
            // - x, y: Posição da nave inimiga (passada como parâmetro)
            // - y - 1.0: Ajuste para sair abaixo da nave
            // - z: 0.05 (ligeiramente à frente para evitar sobreposição visual)
            mesh.position.set(x, y - 1.0, 0.05);
        
            // Adiciona o projétil à cena principal
            scene.add(mesh);
        
            // Armazena o projétil no array global `enemyProjectiles`:
            enemyProjectiles.push({
                mesh,      // Objeto 3D
                dx, dy,    // Direção (normalizada e multiplicada pela velocidade)
                alive: true // Flag para controle
            });
        }
        
        function spawnExplosion(x, y) {
            playSound('explosion');
            let group = [];
            for (let i = 0; i < 15; i++) {
                let geo = new THREE.SphereGeometry(0.13 + Math.random() * 0.09, 6, 6);
                let mat = new THREE.MeshBasicMaterial({ color: Math.random() < 0.5 ? 0xff3300 : 0xff9900 });
                let mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y, 0.1);
                mesh.dx = (Math.random() - 0.5) * 2.2;
                mesh.dy = (Math.random() - 0.5) * 2.2;
                mesh.ttl = 0.45 + Math.random() * 0.2;
                scene.add(mesh);
                group.push(mesh);
            }
            explosions.push({ group, time: 0 });
            
            // 30% chance de dropar power-up
            if (Math.random() < 0.3) {
                spawnPowerUp(x, y);
            }
        }
                
        function spawnPowerUp(x, y) {
            // Toca o som de power-up aparecendo
            playSound('powerup');
        
            // Cria a geometria de uma esfera para o power-up:
            // - Raio: 0.3 unidades
            // - Segmentos horizontais/verticais: 16 (suavidade da esfera)
            let geo = new THREE.SphereGeometry(0.3, 16, 16);
        
            // Define o material do power-up:
            // - Cor base: POWERUP_COLOR (verde, definido nas constantes)
            // - Emissivo: mesma cor (faz o power-up "brilhar" levemente)
            let mat = new THREE.MeshBasicMaterial({ 
                color: POWERUP_COLOR, 
                emissive: POWERUP_COLOR 
            });
        
            // Cria a malha 3D combinando geometria + material
            let mesh = new THREE.Mesh(geo, mat);
        
            // Posiciona o power-up nas coordenadas (x, y) recebidas como parâmetro,
            // com um pequeno offset no eixo Z (0.1) para evitar conflito de renderização
            mesh.position.set(x, y, 0.1);
        
            // Adiciona o power-up à cena principal
            scene.add(mesh);
        
            // Armazena o power-up no array global `powerUps` com suas propriedades:
            powerUps.push({
                mesh,        	// Referência ao objeto 3D
                alive: true, 	// Flag para controle (se ainda está ativo)
                ttl: 9.0,		// Time-To-Live (tempo de vida em segundos)
                dy: -3       	// Velocidade vertical (movimento para baixo)
				//------------------------------------------------------------------------------------------
				// Cálculo da distância percorrida pelo power-up e sua relação com a altura da tela de jogo:
				//
				// Area útil do jogo: PLAY_AREA = { x: XX, y: YY }, onde XX e YY são unidades de distância
				// Distância percorrida = |dy| * ttl (unidades de distância) , onde dy (velocidade), ttl (tempo de vida)
				// P/ o powerup cruzar toda a tela verticalmente: |dy| * ttl > PLAY_AREA.y
				//------------------------------------------------------------------------------------------
            });
        }

        
        function resetGame() {

			// Mostra os painéis do HUD
		    document.getElementById('left-panel').style.display = 'block';
		    document.getElementById('right-panel').style.display = 'block';
			
            // Remove todos os objetos 3D da cena (limpeza total)
            while (scene.children.length) scene.remove(scene.children[0]);
        
            // Reseta arrays de entidades do jogo
            stars = [];            // Partículas de fundo
            enemies = [];          // Inimigos ativos
            projectiles = [];      // Projéteis do jogador
            enemyProjectiles = []; // Projéteis inimigos
            explosions = [];       // Efeitos de explosão
            powerUps = [];         // Power-ups coletáveis
            mothership = null;     // Remove referência à nave-mãe

			// Reseta a fila de músicas
    		audioSettings.playlistQueue = [];
				
			// Reinicia a música
			if (audioEnabled) playPlaylist(); 
			
            // Recria elementos essenciais           
            createPlayer();      // Recria a nave do jogador        
            
            // Reseta status do jogador
            playerHealth = playerMaxHealth;  // Vida máxima
            playerScore = 0;                 // Pontuação zerada
            wave = 1;                        // Volta para a fase 1
            operatorIndex = 0;               // Operador lógico padrão (AND)
            playerVLC = 1;                   // Valor lógico inicial (1)
            updateVLCMesh(playerVLC);        // Atualiza visualização do VLC

			// Reseta o escudo  
		    playerShield = false; 						// Escudo desativado
		    shieldCharge = SHIELD_MAX_CHARGE; 			// Mas carregado (pronto para uso) 
		    shieldTimer = 0;   					        // Reseta o timer  
		    if (shieldAura) shieldAura.visible = false; // Garante que a aura está invisível 
			
            // Reseta timers de disparo
            lastFire = 0;        // Tempo do último tiro do jogador
            lastEnemyFire = 0;   // Tempo do último tiro inimigo
            waveEnemies = 0;     // Contador de inimigos na wave
        
            // Reinicia sistema de bombas
            initBombCounts();            // Recarrega contagem de bombas
            bombReplenishedAtScore = {}; // Limpa registro de recargas

			// Inicia o cronômetro
		    gameStartTime = Date.now();
		    elapsedTime = 0;
			
        }

        function getEnemyType(wave, index) {


	//		Fase	Tipo de Naves						Quantidade		Comportamento/Dinâmica					Intervalo Atualização
	//  -------------------------------------------------------------------------------------------------------------------------------
	//		1		Caças estáticos (nível 1)				5			Valores fixos (0/1)								-
	//		2		Caças dinâmicos (nível 2)				6			Valores mudam aleatoriamente					3s
	//		3		Caças VLC (nível 3)						7			Alternam entre VLC e !VLC do jogador			4s
	//		4		Mistura: níveis 1, 2, 3 (4:2:3)			9			Combina comportamentos das waves 1-3		- / 3s / 4s
	//		5		Cruzadores estáticos (nível 4)			7			Expressões básicas (AND, OR, XOR)				-
	//		6		Cruzadores dinâmicos (nível 5)			4-7			A e B mudam aleatoriamente						5s
	//		7		Cruzadores VLC (nível 6)				4-7			A fixo, B = VLC ou !VLC							4s
	//		8		Mistura: níveis 1, 5, 7 (4:4:4)			12			Caças estáticos + Cruzadores dinâmicos		- / 5s / 4s
	//		9		Mistura: níveis 2, 3, 6, 8 (3:3:4:3)	14			Combina naves dinâmicas complexas			3s / 4s / 5s
	//		10		Nave-mãe + escoltas						1 + extras	Geradores A/B mudam aleatoriamente	
    //  -------------------------------------------------------------------------------------------------------------------------------


			
            // Waves 1-3: Níveis 1-3 puros
            if (wave === 1) return ENEMY_TYPES[0]; // Caças estáticos (nível 1)
            if (wave === 2) return ENEMY_TYPES[1]; // Caças dinâmicos (nível 2)
            if (wave === 3) return ENEMY_TYPES[2]; // Caças VLC (nível 3)
        
            // Wave 4: Mistura de níveis 1-3 (4:2:3)
            if (wave === 4) {
                const types = [0, 0, 0, 0, 1, 1, 2, 2, 2]; // Proporção 4:2:3
                return ENEMY_TYPES[types[index % types.length]];
            }
        
            // Wave 5: Cruzadores básicos (nível 4)
            if (wave === 5) return ENEMY_TYPES[3 + (index % 3)]; // AND, OR, XOR
        
            // Wave 6: Cruzadores dinâmicos (nível 5)
            if (wave === 6) return ENEMY_TYPES[6 + (index % 3)]; // AND, OR, XOR dinâmicos
        
            // Wave 7: Cruzadores dinâmicos A fixo + B = VLC (nível 6)
            if (wave === 7) return ENEMY_TYPES[9 + (index % 3)]; // AND, OR, XOR com B dinâmico
        
            // Wave 8: Mistura de níveis 1, 5, 7 (4:4:4)
            if (wave === 8) {
                const types = [0, 6, 9, 0, 7, 10, 0, 6, 9, 0, 7, 10]; // Proporção 4:4:4
                return ENEMY_TYPES[types[index % types.length]];
            }
        
            // Wave 9: Mistura de níveis 2, 3, 6, 8 (3:3:4:3)
            if (wave === 9) {			    
				//const types = [1, 2, 9, 1, 2, 12, 1, 2, 9, 1, 2, 12, 9, 12]; // Proporção 3:3:4:3
			    const types = [1, 2, 6, 1, 2, 9, 1, 2, 6, 1, 2, 9, 6, 9]; // Proporção 3:3:4:3
			    return ENEMY_TYPES[types[index % types.length]];
			}
        
            // Wave 10: Nave-mãe + escoltas (será implementada separadamente)
            if (wave === 10) return ENEMY_TYPES.find(t => t.isBoss); // Retorna a nave-mãe
        }
        
        function startWave(n) {
            
            // Fase 10: Nave-mãe + escoltas
            if (n === 10) {
                playMothershipTrack();
				spawnMothership();  // Spawna a nave-mãe (função separada que cria a nave-boss)
                waveEnemies = 1;    // Define o contador de inimigos como 1 (só a nave-mãe, escoltas são extras)
                return;             // Sai da função, pois a wave 10 é tratada de forma especial
            } /*else if (n >= 1 && n <= 8) {
		        ();
		    }*/
			
			// Fases 1-9: Inimigos normais
		    let nEnemies;
		    
		    // Define a quantidade de inimigos com base na fase atual (n)
		    if (n === 3) {		        
		        nEnemies = 5;    // Fase 3 tem exatamente 5 inimigos (caças VLC)
		    } else if (n >= 8) {		        
		        nEnemies = 10;   // Fases 8 e 9 têm 10 inimigos (mistura de tipos avançados)
		    } else {		        
		        nEnemies = Math.min(4 + n, 7);  // Fases 1, 2, 4-7: mínimo 4, máximo 7 inimigos (progressão: 4 + número da wave)
				//nEnemies = 3
		    }
		    
		    // Atualiza o contador global de inimigos da wave
		    waveEnemies = nEnemies;
		
		    // Loop para spawnar cada inimigo da wave
		    for (let i = 0; i < nEnemies; i++) {
				
		        // Obtém o tipo de inimigo com base na wave e índice atual
		        let type = getEnemyType(n, i);
		        
		        // Calcula posição X: distribui os inimigos uniformemente na área de jogo
		        // - PLAY_AREA.x: largura total da área
		        // - (i % nEnemies): garante posicionamento cíclico se necessário
		        let x = -PLAY_AREA.x / 2 + 1.5 + (i % nEnemies) * (PLAY_AREA.x - 3) / (nEnemies - 1);
		        
		        // Calcula posição Y: topo da tela com pequena variação aleatória
		        let y = PLAY_AREA.y / 2 - 1.5 - Math.random() * 1.4;
		        
		        // Cria o inimigo e adiciona ao array global
		        enemies.push(spawnEnemy(type, x, y));
            
            }			
			
        }

		function updateHUD() {
			
		    // ===== [Lógica de alertas de vida baixa] =====
		    const isLowHealth = playerHealth <= playerMaxHealth * 0.2;
		    if (isLowHealth && gameState === GAME_STATE.PLAYING) {
		        if (!hud.lowHealthSoundInterval) {
		            playSound('lowHealth');
		            hud.lowHealthSoundInterval = setInterval(() => {
		                if (gameState === GAME_STATE.PLAYING) playSound('lowHealth');
		            }, 1000);
		        }
		        // Efeito visual de piscar (agora aplicado ao texto "■■■□□" no painel direito)
		        document.getElementById('health-value').style.color = 
		            (Math.floor(Date.now() / 200) % 2 === 0 ? '#ff0000' : '#00ff55');
		    } else if (hud.lowHealthSoundInterval) {
		        clearInterval(hud.lowHealthSoundInterval);
		        hud.lowHealthSoundInterval = null;
		        sounds.lowHealth.pause();
		        sounds.lowHealth.currentTime = 0;
		        document.getElementById('health-value').style.color = '#00ff55';
		    }
		
		    // ===== [PAINEL ESQUERDO] =====
		    // VLC (valor e cor)
		    const vlcElement = document.getElementById('vlc-value');
		    vlcElement.textContent = playerVLC;
		    vlcElement.style.color = playerVLC ? '#0090ff' : '#ff2222';

			// Atualiza cargas do escudo
			// ESCUDO (cargas e cor)
			const shieldElement = document.getElementById('shield-value');
			shieldElement.textContent = '■'.repeat(shieldCharge) + '□'.repeat(SHIELD_MAX_CHARGE - shieldCharge);
			
			// Altera a cor conforme o estado
			if (shieldCharge === SHIELD_MAX_CHARGE) {
			    shieldElement.className = 'hud-value ready';     // Verde
			} else if (shieldCharge >= 1) {
			    shieldElement.className = 'hud-value charging';  // Laranja
			} else {
			    shieldElement.className = 'hud-value empty';     // Vermelho
			}
			
		    // Lista de bombas (operadores)
		    const bombList = document.getElementById('bomb-list');
		    bombList.innerHTML = OPERATORS.map((op, index) => {
		        const isSelected = index === operatorIndex;
		        return `<div class="bomb-entry ${isSelected ? 'bomb-selected' : ''}">
		            ${op.key} (${bombCounts[op.key]})
		        </div>`;
		    }).join('');
		
		    // ===== [PAINEL DIREITO] =====
		    document.getElementById('wave-value').textContent = `${wave}/${maxWaves}`;
		    document.getElementById('score-value').textContent = playerScore;
		    //document.getElementById('health-value').textContent = 
		    //    '■'.repeat(playerHealth) + '□'.repeat(playerMaxHealth - playerHealth);
			document.getElementById('health-value').textContent = '■'.repeat(playerHealth);
			if (!isLowHealth) {// Cor padrão da vida (verde) - SOMENTE se não estiver em estado de vida baixa
			    document.getElementById('health-value').style.color = '#00ff88';
			}		    
		    document.getElementById('time-value').textContent = formatTime(elapsedTime);
			
		    // ===== [REMOVE ELEMENTOS FLUTUANTES ANTIGOS] =====
		    if (hud.health && hud.health.parentNode) hud.health.parentNode.removeChild(hud.health);
		    if (hud.score && hud.score.parentNode) hud.score.parentNode.removeChild(hud.score);
		    if (hud.vlc && hud.vlc.parentNode) hud.vlc.parentNode.removeChild(hud.vlc);
		    if (hud.op && hud.op.parentNode) hud.op.parentNode.removeChild(hud.op);
		    if (hud.wave && hud.wave.parentNode) hud.wave.parentNode.removeChild(hud.wave);
		    // NÃO remove hud.bossGens (pois ele continua sendo exibido acima da nave-mãe, como originalmente)
		}

		
		function formatTime(seconds) {
		    const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
		    const secs = (seconds % 60).toString().padStart(2, '0');
		    return `${mins}:${secs}`;
		}

		
        function clearHUD() {

			// Esconde os painéis laterais
		    document.getElementById('left-panel').style.display = 'none';
		    document.getElementById('right-panel').style.display = 'none';
			
            for (let k in hud) {
                if (hud[k] && hud[k].parentNode) hud[k].parentNode.removeChild(hud[k]);
                hud[k] = null;
            }
        }

        function showOverlay(type, text, subtext) {
            let overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.left = '0';
            overlay.style.top = '0';
            overlay.style.width = '100vw';
            overlay.style.height = '100vh';            
            overlay.style.background = `rgba(10,14,42,0.8)`; // Usa o parâmetro de opacidade? 80%
            overlay.style.display = 'flex';
            overlay.style.flexDirection = 'column';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '1000';
            overlay.style.fontFamily = 'monospace';
            let title = document.createElement('div');
            title.style.fontSize = '58px';
            title.style.color = '#fff';
            title.style.textShadow = '0 0 24px #0077ff, 0 0 12px #fff';
            title.style.fontWeight = 'bold';
            title.style.letterSpacing = '2px';
            title.innerHTML = text;
            overlay.appendChild(title);
            if (subtext) {
                let st = document.createElement('div');
                st.style.fontSize = '28px';
                st.style.color = '#fff';
                st.style.marginTop = '28px';
                st.style.textShadow = '0 0 8px #0077ff';
                st.innerHTML = subtext;
                overlay.appendChild(st);
            }
            document.body.appendChild(overlay);
            return overlay;
        }

        function removeOverlay(overlay) {
            if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
        }

        function keyDown(e) {
            if (e.repeat) return;
            keys[e.code] = true;
        
            // Tecla C - Alternar VLC (NOT) - Funciona em qualquer estado
            if (e.code === 'KeyC') {
                playerVLC = 1 - playerVLC;		// Gera o contraditório do VLC
                window.playerVLC = playerVLC;	
                updateVLCMesh(playerVLC);		// Atualiza o valor do VLC sobre o jogador
                return;
            }
        
            switch (gameState) {
                case GAME_STATE.START:
                    if (e.code === 'Space') {  // se está na tela de apresentação e quer iniciar o jogo...
                        removeOverlay(startOverlay);		// Remove a tela inicial
                        resetGame();                       	// Reseta para a fase 1
                        gameState = GAME_STATE.PLAYING;    	// muda o estado do jogo
                        startWave(wave);				   	// Começa na fase 1
                    }
                    break;
        
                case GAME_STATE.GAME_OVER:
                    if (e.code === 'KeyR') {   // se perdeu e quer reiniciar o jogo...
                        removeOverlay(gameOverOverlay);		// Remove a tela de término de jogo
                        clearHUD();					    	// Limpa HUD
                        resetGame();                       	// Reseta para a fase 1
                        gameState = GAME_STATE.PLAYING;    	// muda o estado do jogo
                        startWave(wave);				   	// Começa na fase 1						        				
                    }
                    break;
        
                case GAME_STATE.WIN:
                    if (e.code === 'KeyR') {   // se venceu e quer reiniciar o jogo...
                        removeOverlay(winOverlay);			// Remove a tela de vitória do jogo
                        clearHUD();					    	// Limpa HUD
                        resetGame();                       	// Reseta para a fase 1
                        gameState = GAME_STATE.PLAYING;    	// muda o estado do jogo
                        startWave(wave);				   	// Começa na fase 1						
                    }
                    break;
        
                case GAME_STATE.PLAYING:
					
					if (e.code === 'KeyE' && shieldCharge > 0 && !playerShield) {  // Se quer ativar escudo booleano...
				        playerShield = true;  
				        playSound('booleanShield');
						shieldAura.visible = true;				        
				    }  
					        
                    if (e.code === 'Tab') {  // Se quer trocar a bomba lógica...
                        operatorIndex = (operatorIndex + 1) % OPERATORS.length;
                        e.preventDefault();
                    }
        
                    if (e.code === 'Space') {  // se quer lançar bombas no inimigo...
                        let now = performance.now() / 1000;
                        const currentOperatorKey = OPERATORS[operatorIndex].key;
                        if (bombCounts[currentOperatorKey] > 0 && now - lastFire > fireDelay) {
                            fireProjectile();
                            bombCounts[currentOperatorKey]--;
                            lastFire = now;
                        }
                    }

					if (e.code === 'KeyP') {   // se está jogando e decide pausar o jogo...
                        // Cria overlay de pause com transparência
                        pauseOverlay = document.createElement('div');
                        pauseOverlay.style.position = 'fixed';
                        pauseOverlay.style.left = '0';
                        pauseOverlay.style.top = '0';
                        pauseOverlay.style.width = '100vw';
                        pauseOverlay.style.height = '100vh';
                        pauseOverlay.style.background = 'rgba(10,14,42,0.4)'; // 40% de opacidade, último parâmetro.
                        pauseOverlay.style.display = 'flex';
                        pauseOverlay.style.flexDirection = 'column';
                        pauseOverlay.style.alignItems = 'center';
                        pauseOverlay.style.justifyContent = 'center';
                        pauseOverlay.style.zIndex = '1000';
                        pauseOverlay.style.fontFamily = 'monospace';
                        
                        let title = document.createElement('div');
                        title.style.fontSize = '58px';
                        title.style.color = '#fff';
                        title.style.textShadow = '0 0 24px #0077ff, 0 0 12px #fff';
                        title.style.fontWeight = 'bold';
                        title.style.letterSpacing = '2px';
                        title.innerHTML = 'Jogo Pausado';
                        pauseOverlay.appendChild(title);
                        
                        let subtext = document.createElement('div');
                        subtext.style.fontSize = '28px';
                        subtext.style.color = '#fff';
                        subtext.style.marginTop = '28px';
                        subtext.style.textShadow = '0 0 8px #0077ff';
                        subtext.innerHTML = '<span style="font-size:22px;">Tecle P para continuar</span>';
                        pauseOverlay.appendChild(subtext);
                        
                        document.body.appendChild(pauseOverlay);

						// 2. Pausa QUALQUER áudio em execução (playlist ou nave-mãe)
				        if (sounds.currentTrack) {
				            sounds.currentTrack.pause(); 	// Congela no ponto atual
				        }

						// 3. Pausa o jogo
                        gameState = GAME_STATE.PAUSED;		// Troca o estado
						
                    }					
                    break;
        
                case GAME_STATE.PAUSED:
                    if (e.code === 'KeyP') {  // se quer retomar o jogo que está pausado...
																	
						// 1. Retoma o áudio atual (se existir e o áudio estiver habilitado)
				        if (sounds.currentTrack && audioEnabled) {
				            sounds.currentTrack.play()
				                .catch(e => console.log("Erro ao retomar áudio:", e.name));
				        }
						
						// 2. Muda o estado do jogo
                        gameState = GAME_STATE.PLAYING;  // jogando

						//3. Remove a tela de pausa
                        removeOverlay(pauseOverlay);
						pauseOverlay = null;   // Limpeza final
                    }
                    break;
            }
        }
        
        
        function keyUp(e) {
            keys[e.code] = false;
        }

        function fireProjectile() {
            
            // Inicializa variáveis para encontrar o alvo mais próximo:
            // - `target`: armazenará o inimigo mais próximo
            // - `minDist`: distância mínima inicializada com um valor alto (1000)
            let target = null, minDist = 1000;
        
            // Percorre todos os inimigos ativos no array `enemies`
            for (let e of enemies) {
                // Ignora inimigos mortos
                if (!e.alive) continue;
        
                // Calcula a distância entre o jogador e o inimigo atual (e)
                // Usa diferença de coordenadas (dx e dy) e distância quadrática (d = dx² + dy²)
                // (Distância quadrática é mais eficiente que Math.sqrt)
                let dx = e.mesh.position.x - player.x;
                let dy = e.mesh.position.y - player.y;
                let d = dx * dx + dy * dy;
        
                // Se o inimigo atual estiver mais próximo que o registrado:
                if (d < minDist) {
                    minDist = d;       // Atualiza a distância mínima
                    target = e;        // Define este inimigo como alvo atual
                }
            }
        
            // Verifica se a nave-mãe existe e está viva
            if (mothership && mothership.alive) {
                // Calcula a distância entre jogador e nave-mãe
                let dx = mothership.mesh.position.x - player.x;
                let dy = mothership.mesh.position.y - player.y;
                let d = dx * dx + dy * dy;
        
                // Se a nave-mãe estiver mais próxima que outros inimigos:
                if (d < minDist) {
                    minDist = d;
                    target = mothership; // Prioriza a nave-mãe como alvo
                }
            }
        
            // Se nenhum alvo foi encontrado, encerra a função
            if (!target) return;
        
            // Calcula o vetor direção do jogador para o alvo (target)
            let dx = target.mesh.position.x - player.x;
            let dy = target.mesh.position.y - player.y;
        
            // Calcula a magnitude (distância real) usando Math.sqrt
            let mag = Math.sqrt(dx * dx + dy * dy);
        
            // Evita divisão por zero (caso raro de distância = 0)
            if (mag === 0) mag = 1;
        
            // Normaliza o vetor (transforma em vetor unitário: comprimento = 1)
            dx /= mag;
            dy /= mag;
        
            // Dispara o projétil:
            // - Posição: (player.x, player.y)
            // - Direção: (dx * 13, dy * 13) (13 = velocidade do projétil)
            // - operatorIndex: tipo de operador lógico selecionado
            spawnProjectile(player.x, player.y, dx * 13, dy * 13, operatorIndex);
        }

        
        function enemyFireLogic(dt) {
            // Obtém o tempo atual em segundos (para cálculos de intervalo de disparo)
            let now = performance.now() / 1000;
        
            // Verifica se o tempo desde o último disparo inimigo é maior que o intervalo permitido
            if (now - lastEnemyFire > enemyFireDelay) {
        
                // Itera sobre todos os inimigos ativos
                for (let e of enemies) {
                    // Pula inimigos mortos
                    if (!e.alive) continue;
        
                    // Calcula a direção do jogador em relação ao inimigo (vetor X e Y)
                    let dx = player.x - e.mesh.position.x;
                    let dy = player.y - e.mesh.position.y;
        
                    // Calcula a magnitude (distância) entre inimigo e jogador
                    let mag = Math.sqrt(dx * dx + dy * dy);
        
                    // Evita divisão por zero (caso raro de distância zero)
                    if (mag === 0) mag = 1;
        
                    // Normaliza o vetor de direção (transforma em vetor unitário)
                    dx /= mag;
                    dy /= mag;
        
                    // 70% de chance de disparar (Math.random() < 0.7)
                    if (Math.random() < 0.7)
                        // Cria um projétil na posição do inimigo, com direção ao jogador e velocidade 8
                        spawnEnemyProjectile(e.mesh.position.x, e.mesh.position.y, dx * 8, dy * 8);
                }
        
                // Lógica similar para a nave-mãe (se existir e estiver viva)
                if (mothership && mothership.alive && Math.random() < 0.8) {
                    let dx = player.x - mothership.mesh.position.x;
                    let dy = player.y - mothership.mesh.position.y;
                    let mag = Math.sqrt(dx * dx + dy * dy);
                    if (mag === 0) mag = 1;
                    dx /= mag;
                    dy /= mag;
        
                    // Dispara com velocidade 9 (ligeiramente mais rápido que inimigos normais)
                    // O -0.6 no Y posiciona o tiro abaixo da nave-mãe
                    spawnEnemyProjectile(mothership.mesh.position.x, mothership.mesh.position.y - 0.6, dx * 9, dy * 9);
                }
        
                // Atualiza o tempo do último disparo
                lastEnemyFire = now;
            }
        }
        

		function updateProjectiles(dt) {
			
		    for (let p of projectiles) {if (!p.alive) continue;
		
		        // Movimento do projétil 
		        p.mesh.position.x += p.dx * dt;
		        p.mesh.position.y += p.dy * dt;
		
		        // Remove projéteis fora da tela 
		        if (Math.abs(p.mesh.position.x) > PLAY_AREA.x / 2 + 2 || Math.abs(p.mesh.position.y) > PLAY_AREA.y / 2 + 2) {
		            scene.remove(p.mesh);
		            p.alive = false;
		            continue;
		        }
		
		        // Verifica colisão com TODAS as naves (inclusive nave-mãe)
		        let targetShips = [...enemies];
		        if (mothership && mothership.alive) targetShips.push(mothership);
		
		        for (let e of targetShips) {
		            if (!e.alive) continue;

					// cálculo para saber se o projétil atingiu a nave número "e"
		            let dist = Math.sqrt((e.mesh.position.x - p.mesh.position.x) ** 2 + (e.mesh.position.y - p.mesh.position.y) ** 2);
		            let hitRadius = e.isBoss ? 1.5 : 0.8; // Raio de colisão da nave: 1,5 para a nave-mãe, 0,8 para as restantes

					// Se o projétil está dentro do raio de colisão da nave número "e"... 
		            if (dist < hitRadius) {
						// Coleta os operandos e a operação lógica a ser aplicada aos primeiros p/ verificar se 
						// o projétil irá gerar dano a nave inimiga ou seu escudo booleano a protejerá
		                let op = OPERATORS[p.operator];  // Bomba lógica (Operador) selecionada pelo jogador
		                let vlc = playerVLC;   // Valor lógico do jogador (0 ou 1)
		                let ev = e.ev; // Valor lógico do inimigo (calculado em spawnEnemy() ou updateDynamicEnemies())
		
		                // Cálculo universal de dano (igual para todas as naves):
						// Se a operação da bomba lógica sobre o VLC e o valor lógico final da nave inimiga deve ser 1...
		                if (op.fn(vlc, ev) === 1) {   
		                    e.health--;               // Causa dano: decrementa a vida da nave inimiga
		                    setBarValue(e.healthBar, e.health / e.maxHealth);  // Causa dano: atualiza isso na barra de vida da nave

							// Se último dano faz a nave "morrer"... 
		                    if (e.health <= 0) {
		                        e.alive = false;        // Atualizada status da nave: agora está morta
		                        scene.remove(e.mesh);   // A remove da cena
		                        spawnExplosion(e.mesh.position.x, e.mesh.position.y);  // Gera o som de explosão
		                        playerScore += e.isBoss ? 1000 : 100; // Incrementa pontuação do jogador: 1000 para nave-mãe 100 para qualquer outra nave
		                        if (!e.isBoss) waveEnemies--;  // Decrementa número de inimigos vivos na fase atual
		                    }
		                }

						console.log(`DANO: ${e.expr} | A=${e.A}, B=${e.B} | VLC=${vlc}, OP=${op.key} | EV=${e.ev} | RESULT=${op.fn(vlc, e.ev)}`);
						
		                scene.remove(p.mesh);
		                p.alive = false;
		                break;
		            }
		        }
		    }
		    projectiles = projectiles.filter(p => p.alive);
		}
        
        function updateEnemyProjectiles(dt) {
            // Itera sobre todos os projéteis inimigos ativos
            for (let p of enemyProjectiles) {
                if (!p.alive) continue; // Ignora projéteis marcados como inativos
        
                // Atualiza posição do projétil com base na velocidade (dx, dy) e delta time
                p.mesh.position.x += p.dx * dt;
                p.mesh.position.y += p.dy * dt;
        
                // Verifica se o projétil saiu dos limites da área de jogo
                if (Math.abs(p.mesh.position.x) > PLAY_AREA.x / 2 + 2 || 
                    Math.abs(p.mesh.position.y) > PLAY_AREA.y / 2 + 2) {
                    scene.remove(p.mesh); // Remove visualmente
                    p.alive = false;      // Marca como inativo
                    continue;
                }
        
                // Calcula distância entre o projétil e o jogador
                let px = p.mesh.position.x, py = p.mesh.position.y;
                let dist = Math.sqrt((player.x - px) ** 2 + (player.y - py) ** 2);
        
                // Verifica colisão com o jogador (raio de 0.7 unidades)
                if (dist < 0.7) {
                    // Remove o projétil da cena
                    scene.remove(p.mesh);
                    p.alive = false;

					// Verifica se o escudo está ativo
					if (playerShield) {
					    shieldCharge--;           			     	// Consome uma carga do escudo
					    playSound('shieldHit');         			// Som de escudo atingido
					    shieldAura.visible = (shieldCharge > 0); 	// Some se acabarem as cargas
					    playerShield = (shieldCharge > 0);       	// Desativa se acabarem as cargas
					}
					// Se não tem escudo ativo, aplica dano
					else {					
	                    // Aplica dano ao jogador
	                    playerHealth--;
	                    setBarValue(playerHealthBar, playerHealth / playerMaxHealth); // Atualiza HUD
	                    playSound('playerHit'); // Toca som de impacto
	        
	                    // Verifica morte do jogador
	                    if (playerHealth <= 0) {
	                        
	                        // Ativa estado de Game Over
	                        gameState = GAME_STATE.GAME_OVER;
							sounds.currentTrack.pause(); // Para a música atual
	    					sounds.currentTrack.currentTime = 0; // Reinicia a música
	                        playSound('gameOver'); // Toca som de derrota
	                        
	                        // Exibe overlay de Game Over
	                        gameOverOverlay = showOverlay(
	                            'gameover', 
	                            'GAME OVER', 
	                            'Pontuação: ' + playerScore + '<br><br>Tecle R para reiniciar'
	                        );
	                    }
					}
                }
            }
        
            // Filtra apenas projéteis ativos (remove os marcados como !alive)
            enemyProjectiles = enemyProjectiles.filter(p => p.alive);
        }

        
        function updateExplosions(dt) {
            for (let e of explosions) {
                for (let m of e.group) {
                    m.position.x += m.dx * dt;
                    m.position.y += m.dy * dt;
                    m.ttl -= dt;
                    if (m.ttl < 0) {
                        scene.remove(m);
                    }
                }
            }
            explosions = explosions.filter(e => e.group.some(m => m.ttl > 0));
        }

        function updatePowerUps(dt) {
            for (let pu of powerUps) {
                if (!pu.alive) continue;
                
                // Movimento do power-up (velocidade constante, independente do tamanho da área)
                pu.mesh.position.y += pu.dy * dt;
                pu.ttl -= dt;
        
                // Condição de destruição: 
                // 1. Tempo esgotado -OU- 
                // 2. Saiu da área visível (baseado em PLAY_AREA.y atual)
				const destroyThreshold = -PLAY_AREA.y * 0.9; // 80% da altura (Ajuste para controlar quando desaparece. Quanto MAIOR, 
                                                                            // mais próximo do final da tela.                
                if (pu.ttl < 0 || pu.mesh.position.y < destroyThreshold) {
                    scene.remove(pu.mesh);
                    pu.alive = false;
                    continue;
                }
        
                // Colisão com o jogador
                let dist = Math.sqrt((player.x - pu.mesh.position.x) ** 2 + (player.y - pu.mesh.position.y) ** 2);
                if (dist < 1.0) {
                    playSound('powerupCollect');
                    for (let key in bombCounts) {
                        if (key === 'OR' || key === 'NAND') {
                            bombCounts[key] = Math.min(bombCounts[key] + 3, 20);
                        } else if (key === 'NOR') {
                            bombCounts[key] = Math.min(bombCounts[key] + 5, 20);
                        } else {
                            bombCounts[key] = Math.min(bombCounts[key] + 4, 20);
                        }
                    }
                    scene.remove(pu.mesh);
                    pu.alive = false;
                    
                    // Efeito visual
                    let particles = [];
                    for (let i = 0; i < 20; i++) {
                        let geo = new THREE.SphereGeometry(0.1, 6, 6);
                        let mat = new THREE.MeshBasicMaterial({ color: POWERUP_COLOR });
                        let mesh = new THREE.Mesh(geo, mat);
                        mesh.position.set(pu.mesh.position.x, pu.mesh.position.y, 0.1);
                        mesh.dx = (Math.random() - 0.5) * 3;
                        mesh.dy = (Math.random() - 0.5) * 3;
                        mesh.ttl = 0.8 + Math.random() * 0.4;
                        scene.add(mesh);
                        particles.push(mesh);
                    }
                    explosions.push({ group: particles, time: 0 });
                }
            }
            powerUps = powerUps.filter(pu => pu.alive);
        }
        
        function checkScoreForBombReplenish() {
            const scoreThresholds = [500, 1500, 3000, 5000, 8000];
            for (const threshold of scoreThresholds) {
                if (playerScore >= threshold && !bombReplenishedAtScore[threshold]) {
                    for (let key in bombCounts) {
                        bombCounts[key] = Math.min(bombCounts[key] + 10, INITIAL_BOMB_COUNT * 2);
                    }
                    bombReplenishedAtScore[threshold] = true;
                    break;
                }
            }
        }

        function updatePlayer(dt) {
            let moveX = 0, moveY = 0;
            if (keys['KeyA'] || keys['ArrowLeft']) moveX -= 1;
            if (keys['KeyD'] || keys['ArrowRight']) moveX += 1;
            if (keys['KeyW'] || keys['ArrowUp']) moveY += 1;
            if (keys['KeyS'] || keys['ArrowDown']) moveY -= 1;
            let mag = Math.sqrt(moveX * moveX + moveY * moveY);
            if (mag > 0) {
                moveX /= mag; moveY /= mag;
                player.x += moveX * player.speed * dt;
                player.y += moveY * player.speed * dt;
                player.x = Math.max(-PLAY_AREA.x / 2 + 0.8, Math.min(PLAY_AREA.x / 2 - 0.8, player.x));
                player.y = Math.max(-PLAY_AREA.y / 2 + 0.7, Math.min(PLAY_AREA.y / 2 - 0.7, player.y));
                playerShip.position.set(player.x, player.y, 0);
                playerVLCMesh.position.set(player.x, player.y + 2.5, 0);
            }
            playerThruster.material.opacity = 0.7 + 0.2 * Math.abs(Math.sin(performance.now() / 110));
        }

		// ===== [SISTEMA DE MOVIMENTO DE INIMIGOS] ===== //

		// 1. Caças (zigue-zague agressivo)
		function updateFighterMovement(e, dt, now, phaseMultiplier) {
		    const freq = 600 - (phaseMultiplier * 100);
		    const amp = 0.5 + (phaseMultiplier * 0.3);
		    const zig = Math.sin(now / freq) * amp;
		    const zag = Math.cos(now / (freq * 0.7)) * (amp * 0.8);
			
		    e.mesh.position.x += zig * dt;			
			// Só move para baixo se não atingiu o limite  
		    if (e.mesh.position.y > ENEMY_LIMIT_Y) {  
		        e.mesh.position.y += zag * dt - (0.4 * phaseMultiplier * dt);  
		    } else {  
		        // Mantém no limite e só se move horizontalmente  
		        e.mesh.position.y = ENEMY_LIMIT_Y;  		       
		    }  
		}
		
		// 2. Cruzadores (ondas suaves)
		function updateCruiserMovement(e, dt, now, phaseMultiplier) {
		    const waveFreq = 800 - (phaseMultiplier * 150);
		    const waveAmp = 0.4 + (phaseMultiplier * 0.2);
		    const wave = Math.sin(now / waveFreq + e.mesh.position.x * 0.5) * waveAmp;
		    
			e.mesh.position.x += wave * dt;			
			// Só move para baixo se não atingiu o limite  
		    if (e.mesh.position.y > ENEMY_LIMIT_Y) {  
		        e.mesh.position.y -= (0.3 + phaseMultiplier * 0.2) * dt;  // controla a descida das naves em direção ao jogador
		    } else {  
		        // Mantém no limite e só se move horizontalmente  
		        e.mesh.position.y = ENEMY_LIMIT_Y;		    
		    }
			
		}
		
		// 3. Destroyers (bloqueador tático)
		function updateDestroyerMovement(e, dt, now, phaseMultiplier) {
		    const blockFreq = 1000 - (phaseMultiplier * 200);
		    const blockAmp = 0.6 + (phaseMultiplier * 0.4);
		    const blockMove = Math.sin(now / blockFreq) * blockAmp;
		    const advance = Math.max(0, (player.y - e.mesh.position.y) * 0.01);
			
		    e.mesh.position.x += blockMove * dt;			
			// Só move para baixo se não atingiu o limite  
		    if (e.mesh.position.y > ENEMY_LIMIT_Y) {  
		        e.mesh.position.y -= (0.2 + advance) * dt;   // controla a descida das naves em direção ao jogador
		    } else {  
		        // Mantém no limite e só se move horizontalmente  
		        e.mesh.position.y = ENEMY_LIMIT_Y;  		        
		    }
		}
		
		// 4. Nave-Mãe (ameaça imponente)
		function updateMothershipMovement(e, dt, now) {
		    const sway = Math.sin(now / 1200) * 0.8;
		    const pulse = Math.sin(now / 800) * 0.3;
		    e.mesh.position.x += sway * dt;
			if (e.mesh.position.y > ENEMY_LIMIT_Y + 3) { // Para 5 unidades acima do limite  
		        e.mesh.position.y += pulse * dt - 0.1 * dt;  
		    } else {  
		        // Fica estacionária em uma posição de "chefe"  
		        e.mesh.position.y = ENEMY_LIMIT_Y + 3;  
		    }			
		}

		// ============================================= //
		
		
        function gameLoop() {
            
            // Obtém o tempo atual em milisegundos
            let now = performance.now();
            
            // Calcula o delta time (tempo desde o último frame), limitando a 45ms para evitar bugs
            let dt = Math.min((now - lastUpdate) / 1000, 0.045);
            
            // Atualiza o último registro de tempo
            lastUpdate = now; 

			// Atualização do tempo
		    elapsedTime = Math.floor((Date.now() - gameStartTime) / 1000);
		    document.getElementById('time-value').textContent = formatTime(elapsedTime);
			
            // Lógica executada apenas durante o estado de jogo (PLAYING)
            if (gameState === GAME_STATE.PLAYING) {
                
                // Chama updateDynamicEnemies a cada frame
                 updateDynamicEnemies(dt);

                // Se estiver na fase da nave-mãe e ela estiver viva, atualiza os geradores dela.
                if (mothership && mothership.alive) updateMothership(dt); 
                
                // Atualiza a posição do jogador
                updatePlayer(dt);
                
                // Atualiza projéteis do jogador e inimigos
                updateProjectiles(dt);
                updateEnemyProjectiles(dt);
                
                // Atualiza efeitos de explosão e power-ups
                updateExplosions(dt);
                updatePowerUps(dt);
                
                // Lógica de disparo dos inimigos
                enemyFireLogic(dt);
                
                // Atualiza comportamentos específicos da nave-mãe (se existir)
                updateMothership(dt);

				// Recarga do escudo (apenas se estiver totalmente descarregado e desativado)  
				if (shieldCharge === 0 && !playerShield) {  
				    shieldTimer += dt;  
				    if (shieldTimer >= shieldCooldown) {  
				        shieldCharge = SHIELD_MAX_CHARGE;  // Recarrega totalmente  
				        shieldTimer = 0;    			   // Reseta o timer  
				    }  
				}  
				
                // Movimentação oscilatória dos inimigos (efeito "flutuante")
                for (let e of enemies) {
                    if (!e.alive) continue;
                    let t = Math.sin(now / 800 + e.mesh.position.x * 0.7) * 0.7;
                    e.mesh.position.y += Math.sin(now / 1300 + e.mesh.position.x * 0.5) * 0.3 * dt;
                    e.mesh.position.x += t * dt * 0.25;
                }

				// Movimentação dos inimigos (baseada no tipo)
				for (let e of enemies) {
				    if (!e.alive) continue;
				    
				    // Calcula multiplicador da fase (ex: fase 1 = 0, fase 9 = 2.0)
				    const phaseMultiplier = Math.min(2.0, (wave - 1) * 0.25);
				    
				    switch (e.movementType) {
				        case 'fighter':
				            updateFighterMovement(e, dt, now, phaseMultiplier);
				            break;
				        case 'cruiser':
				            updateCruiserMovement(e, dt, now, phaseMultiplier);
				            break;
				        case 'destroyer':
				            updateDestroyerMovement(e, dt, now, phaseMultiplier);
				            break;
				        case 'mothership':
				            updateMothershipMovement(e, dt, now);
				            break;
				        default:
				            // Fallback seguro (movimento original)
				            let t = Math.sin(now / 800 + e.mesh.position.x * 0.7) * 0.7;
				            e.mesh.position.y += Math.sin(now / 1300 + e.mesh.position.x * 0.5) * 0.3 * dt;
				            e.mesh.position.x += t * dt * 0.25;
				    }
				}
        
                // Verifica se a wave atual foi concluída
                if (waveEnemies === 0 && !mothership && wave <= maxWaves) {
                    if (wave === maxWaves) {
                        // Wave 10: spawna a nave-mãe
                        spawnMothership();
                        waveEnemies = 1;
                    } else {
                        // Avança para a próxima wave
                        wave++;
                        startWave(wave);
                    }
                }
        
                // Verifica vitória (destruição da nave-mãe)
                if (mothership && !mothership.alive && gameState === GAME_STATE.PLAYING) {
                    // Ativa estado de vitória
                    gameState = GAME_STATE.WIN;
                    playSound('victory');
                    
                    // Mostra overlay de vitória
                    winOverlay = showOverlay(
                        'win', 
                        'VITÓRIA! VOCÊ ANIQUILOU A ARMADA KODAN!', 
                        'Pontuação: ' + playerScore + '<br><br>Tecle R para reiniciar'
                    );
                }
        
                // Verifica recarga de bombas por pontuação
                checkScoreForBombReplenish();
                
                // Atualiza a interface do jogador (HUD)
                updateHUD();
            }
        
            // Renderiza a cena e chama o próximo frame
            renderer.render(scene, camera);
            requestAnimationFrame(gameLoop);
            
        }  
        
        // Inicialização do jogo    
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
                            
            // Atualiza câmera 3D (naves)
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            
            // Redimensiona a imagem de fundo
            renderer.setSize(width, height);
        });
        
        window.addEventListener('keydown', keyDown);
        window.addEventListener('keyup', keyUp);

		window.addEventListener('blur', () => {
	    	if (sounds.currentTrack) sounds.currentTrack.pause();
		});
		
		window.addEventListener('focus', () => {
		    if (audioEnabled && sounds.currentTrack) {
		        sounds.currentTrack.play().catch(e => {});
		    }
		});

        createRenderer();
        createCamera();
        createScene();
        initBombCounts();
        startOverlay = showOverlay('start', 'O Último Guerreiro Digital das Estrelas', '<span style="font-size:22px;">Tecle ESPAÇO para iniciar</span>');
        gameLoop();
    </script>
</body>
</html>
